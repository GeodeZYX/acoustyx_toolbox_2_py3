# -*- coding: utf-8 -*-
"""
Created on Sat Feb 20 16:47:51 2016

@author: psakicki
"""

import matplotlib
matplotlib.use('Agg')

import matplotlib.pyplot as plt

from megalib import *

picknam = "20160223_144248_benmk_direct_eqiv.pik"
picknam = "20160304_191826_benmk_direct.pik"
picknam = "20160309_042636_benmk_direct.pik"

if gf.get_computer_name() == 'calipso':
    pickdir = "/home/psakicki/THESE/CODES/CodePython/acoustyx_toolbox_2/scripts/benchmark_rt/results/direct/"
    plotdir = "/home/psakicki/THESE/RENDU/1603_graphs_benchmk_rt/direct/"
    plotdir = "/home/psakicki/THESE/RENDU/1603_graphs_benchmk_rt/direct/"
    plotdir = '/home/psakicki/THESE/CODES/CodePython/acoustyx_toolbox_2/scripts/benchmark_rt/results_REBOOT1703/PLOT/'
else:    
    pickdir =  "/home/psakicki/Documents/CODES/acoustyx_toolbox_2/scripts/benchmark_rt/results/direct/"
    plotdir = "/home/psakicki/RENDU_1603_graphs_benchmk_rt/direct/"

inppick = os.path.join(pickdir,picknam)


plotdir = gf.create_dir(plotdir)

D = gf.pickle_loader(inppick)

keylis = list(D.keys())

anglis  = sorted(list(set([e[3] for e in keylis])))
zmaxlis = sorted(list(set([e[2] for e in keylis])))
resolis = sorted(list(set([e[1] for e in keylis])))

refzmax = 2000
refang  = 40

z_ang_tup_lis = list(itertools.product(zmaxlis,anglis))
#z_ang_tup_lis = [z_ang_tup_lis[0]]

aleady_treated_zang = []

kompt = 0

resultlis = []

for k in keylis:
    h , reso , zmax  , ang , adap = k
    
    zangtup = (zmax,ang)
    if zangtup in aleady_treated_zang or reso != 'rkdp':
        continue
    else:
        aleady_treated_zang.append(zangtup)
    
    kompt += 1
    
    sol_sd     = D[k]['SD']
    sd_ref_pt  = np.array([sol_sd[0][0] , sol_sd[0][1]])
    sd_ref_s   = sol_sd[0][-1]
    sd_ref_t   = sol_sd[0][-2]
    
    sol_equiv_z         = D[k]['equiv_z']
    equi_z_x            = sol_equiv_z[0][0]
    equi_z_z            = sol_equiv_z[0][1]
    equi_z_s            = sol_equiv_z[0][2]
    equi_z_t            = sol_equiv_z[0][-1]
    sol_equiv_z_pt      = np.array([sol_equiv_z[0][0] , sol_equiv_z[0][1]]) 
    diff_pt_sd_equiv_z  = np.linalg.norm(sd_ref_pt - sol_equiv_z_pt)
    diff_z_s            = equi_z_s - sd_ref_s
    diff_z_t            = equi_z_t - sd_ref_t
    
    print('Z', zmax , ang , diff_pt_sd_equiv_z , diff_z_s , diff_z_t)
    resultlis.append(np.array([ 26, zmax , ang , diff_pt_sd_equiv_z , diff_z_s , diff_z_t]))
    
    sol_equiv_x         = D[k]['equiv_x']
    equi_x_x            = sol_equiv_x[0][0]
    equi_x_z            = sol_equiv_x[0][1]
    equi_x_s            = sol_equiv_x[0][2]
    equi_x_t            = sol_equiv_x[0][-1]
    sol_equiv_x_pt      = np.array([sol_equiv_x[0][0] , sol_equiv_x[0][1]])  
    diff_pt_sd_equiv_x  = np.linalg.norm(sd_ref_pt - sol_equiv_x_pt)
    diff_x_s            = equi_x_s - sd_ref_s
    diff_x_t            = equi_x_t - sd_ref_t    

    print('X', zmax , ang , diff_pt_sd_equiv_x , diff_x_s , diff_x_t)
    resultlis.append(np.array([ 24, zmax , ang , diff_pt_sd_equiv_x , diff_x_s , diff_x_t]))

    sol_equiv_s         = D[k]['equiv_s']
    equi_s_x            = sol_equiv_s[0][0]
    equi_s_z            = sol_equiv_s[0][1]
    equi_s_s            = sol_equiv_s[0][2]
    equi_s_t            = sol_equiv_s[0][-1]

    sol_equiv_s_pt      = np.array([sol_equiv_s[0][0], 
                                    sol_equiv_s[0][1]])  
                                    
    diff_pt_sd_equiv_s  = np.linalg.norm(sd_ref_pt - sol_equiv_s_pt)
    diff_s_s            = equi_s_s - sd_ref_s
    diff_s_t            = equi_s_t - sd_ref_t     
    
    print('S', zmax , ang , diff_pt_sd_equiv_s , diff_s_s , diff_s_t)  
    resultlis.append(np.array([ 19, zmax , ang , diff_pt_sd_equiv_s ,
                               diff_s_s , diff_s_t]))

    # En fait le s2 c'est débile parce que l'idée c'est d'avoir un s a priori
    # si on utilise un s fabriqué a partir des valeurs de x et y d'un autre calcul
    # ca n'a pas de sens
    sol_equiv_s2        = D[k]['equiv_s2']
    sol_equiv_s2_pt     = np.array([sol_equiv_s2[0][0] , sol_equiv_s2[0][1]])  
    diff_pt_sd_equiv_s2 = np.linalg.norm(sd_ref_pt - sol_equiv_s2_pt)
    
resultarr = np.vstack(resultlis)

titdic     = dict()
titdic[19] = 'equivalent raytracing vs Snell-Descartes raytracing using path length as stop parameter'
titdic[26] = 'equivalent raytracing vs Snell-Descartes raytracing using depth as stop parameter '
titdic[24] = 'equivalent raytracing vs Snell-Descartes raytracing using radial propagation as stop parameter '
logplot = 1

logscale = True

if logscale:
    logsuffix = ' (log. scale)'
else:
	logsuffix = ''


for stopkrit in [19 , 24 , 26]: 
    resultarrS = resultarr[resultarr[:,0] == stopkrit]
    
    fig , axarr = plt.subplots(2,2)
    fig.suptitle(titdic[stopkrit])
    
    alist = []
    for a in np.unique(resultarrS[:,2]):
        alist.append(resultarrS[resultarrS[:,2] == a])
    
    for al in alist:
        X,Y = gf.sort_binom_list(al[:,1],al[:,3])
        axarr[0,0].set_title('point position difference in function of \n max. depth at constant angle')
        axarr[0,0].plot(X,np.abs(Y),'o-',label=str(int(al[0,2]))+ '°')
        axarr[0,0].legend(loc='best')
        if logplot:
            axarr[0,0].set_yscale('log')
        axarr[0,0].set_ylabel('distance difference (m)' + logsuffix)
        axarr[0,0].set_xlabel('maximum depth (m)'  )
        X,Y = gf.sort_binom_list(al[:,1],al[:,5])
        axarr[1,0].set_title('propagation time difference in function of \n max. depth at constant emission angle')
        axarr[1,0].plot(X,np.abs(Y),'o-',label=str(int(al[0,2]))+ '°')
        axarr[1,0].legend(loc='best')
        axarr[1,0].set_ylabel('propagation time (s)' + logsuffix) 
        axarr[1,0].set_xlabel('maximum depth (m)'  )
        
    zlist = []
    for z in np.unique(resultarrS[:,1]):
        zlist.append(resultarrS[resultarrS[:,1] == z])
    
    for zl in zlist:
        X,Y = gf.sort_binom_list(zl[:,2],zl[:,3])
        axarr[0,1].plot(X,np.abs(Y),'o-',label=str(int(zl[0,1]))+'m')
        axarr[0,1].legend(loc='best')
        if logplot:
            axarr[0,1].set_yscale('log')
        axarr[0,1].set_ylabel('distance difference (m)'+logsuffix)
        axarr[0,1].set_xlabel('emission angle (deg.)')
        axarr[0,1].set_title('point position difference in function of \n emission angle at constant max. depth')
        X,Y = gf.sort_binom_list(zl[:,2],zl[:,5])
        axarr[1,1].plot(X,np.abs(Y),'o-',label=str(int(zl[0,1]))+'m')
        axarr[1,1].legend(loc='best')
        axarr[1,1].set_ylabel('propagation time (s)'+logsuffix)
        axarr[1,1].set_xlabel('emission angle (deg.)')
        axarr[1,1].set_title('propagation time difference in function of \n emission angle at constant max. depth')
    if logscale:
        [a.set_yscale('log') for a in axarr.flat]
    #fig.set_size_inches(16.53,11.69)
    fig.set_size_inches(11.69/np.sqrt(2),11.69/np.sqrt(2))
    fig.tight_layout()
    plt.subplots_adjust(top=0.88)
    pltname = gf.join_improved('_', 'direct','equiv',gf.alphabet()[stopkrit - 1])
    pltpath = os.path.join(plotdir, pltname)
    plt.savefig(pltpath + '.png')
    plt.savefig(pltpath + '.pdf')
    
    
