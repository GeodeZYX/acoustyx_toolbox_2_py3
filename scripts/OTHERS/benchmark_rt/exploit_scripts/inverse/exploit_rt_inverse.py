# -*- coding: utf-8 -*-
"""
Created on Thu Feb 25 16:40:22 2016

@author: psakicki
"""

#import matplotlib
#matplotlib.use('Agg')
import matplotlib.pyplot as plt

from megalib import *

picknam   = '20160225_134714benchmark_rt_inverse.pik'
picknam   = '20160225_234131benchmark_rt_inverse.pik'
picknam   = '20160302_221416benchmark_rt_inverse.pik'
picknam   = "20160304_232452benchmark_rt_inverse.pik"
picknam   = '20160309_193153benchmark_rt_inverse.pik'

if gf.get_computer_name() == 'calipso':
    pickdir = "/home/psakicki/THESE/CODES/CodePython/acoustyx_toolbox_2/scripts/benchmark_rt/results/inverse/"
    plotdir = "/home/psakicki/THESE/RENDU/1603_graphs_benchmk_rt/indirect/"
    plotdir = '/home/psakicki/THESE/CODES/CodePython/acoustyx_toolbox_2/scripts/benchmark_rt/results_REBOOT1703/PLOT/std/'
else:    
    pickdir = "/home/psakicki/Documents/CODES/acoustyx_toolbox_2/scripts/benchmark_rt/results/inverse/"
    pickdir = '/home/psakicki/THESE/CODES/CodePython/acoustyx_toolbox_2/scripts/benchmark_rt/results/inverse/'
    pickdir = '/home/adminuser/Documents/CODES/acoustyx_toolbox_2_py3/scripts/AUTRES/benchmark_rt/results/inverse/'
    plotdir = "/home/psakicki/RENDU_1603_graphs_benchmk_rt/indirect/"
    plotdir = '/home/psakicki/THESE/CODES/CodePython/acoustyx_toolbox_2/scripts/benchmark_rt/results_REBOOT1703/PLOT/std/'
    plotdir = '/home/adminuser/Documents/CODES//acoustyx_toolbox_2_py3/scripts/AUTRES/benchmark_rt/results_REBOOT1712/PLOT/std/'
    
    
    
path = os.path.join(pickdir,picknam)

L    = gf.pickle_loader(path)
D = dict()

for l in L:
    D[l[0]]          = dict()
    D[l[0]]['SD']    = l[1] # Ang , X dafuq ??? , T , S , exect
    D[l[0]]['eiko']  = l[2] # obj (obj.x = angles and S) ,S , T , exectime1 (of the last exp), exectime2 (the mean)
    D[l[0]]['equiv'] = l[3] # S, Ang, C, T ,exec time

stklis = []

for i, (k,datadico) in enumerate(D.items()):
    sd_t       = datadico['SD'][2]
    sd_s       = datadico['SD'][3]
    sd_a       = datadico['SD'][0]

    try:
        eiko_t = datadico['eiko'][1][-1]
        eiko_s = datadico['eiko'][1][1]
        eiko_a = datadico['eiko'][0].x[0]
        eiko_time = datadico['eiko'][-1]

    except:
        eiko_t = np.nan
        eiko_s = np.nan
        eiko_a = np.nan
    
    equiv_t    = datadico['equiv'][-2]
    equiv_s    = datadico['equiv'][0]
    equiv_a    = datadico['equiv'][1]
    equiv_time = datadico['equiv'][-1]
    
    diff_eiko_t  = sd_t - eiko_t
    diff_eiko_s  = sd_s - eiko_s
    diff_eiko_a  = 90 - (sd_a - eiko_a)

    diff_equiv_t = sd_t - equiv_t
    diff_equiv_s = sd_s - equiv_s
    diff_equiv_a = sd_a - equiv_a
    
    stklis.append(k[:-1]  + ( sd_t , sd_s , eiko_t , eiko_s ,eiko_time, equiv_t , equiv_s , equiv_time,  \
    diff_eiko_t , diff_equiv_t  , diff_eiko_s , diff_equiv_s , diff_eiko_a , diff_equiv_a))

pdt = pd.DataFrame(stklis)

      
renamedic = gf.renamedic_fast_4_pandas('h','resotype','adapbool','x','y','zmax',
             'sd_t' , 'sd_s' , 'eiko_t' ,'eiko_s','eiko_time',
             'equiv_t' ,'equiv_s','equiv_time','diff_eiko_t' , 'diff_equiv_t'  ,
             'diff_eiko_s' , 'diff_equiv_s', 'diff_eiko_a' , 'diff_equiv_a')
    
pdt_proto = pdt.rename(columns=renamedic)

xlis = np.unique(pdt_proto['x'])
ylis = np.unique(pdt_proto['y'])
zlis = np.unique(pdt_proto['zmax'])

xlis = [3000]
ylis = [0]
zlis = [3000]

xlis = [500,3000]
ylis = [0]
zlis = [500,3000]

#varalis = [ e for e in varalis if e[0] in (np.min(xlis),np.max(xlis)) and \
#                                  e[1] in (np.min(ylis),np.max(ylis))]

#varalis  = [ e for e in varalis if e[0] > e[1] ]

varalis = list(itertools.product(xlis,ylis,zlis))

# cas extremes

if 1:
    xtrem = True
    xmin = np.min(np.unique(pdt_proto['x']))
    xmax = np.max(np.unique(pdt_proto['x']))
    zmin = np.min(np.unique(pdt_proto['zmax']))
    zmax = np.max(np.unique(pdt_proto['zmax']))
    varalis = [ vara for vara in varalis if (( vara[0] in (xmin,xmax)) and (vara[2] in (zmin,zmax)))]
    varalis.remove(varalis[2])
else:
    xtrem = False
           
###############################################
#      EIKONIK
###############################################

rmeuler = 1

if 1:
    if len(varalis) != 1:
        mono_data = False
        fig , axarr = plt.subplots(len(varalis) ,4)
    else:
        mono_data = True
        fig , axarr = plt.subplots(2,2)
    

    if rmeuler:
        pdt_proto2 = pdt_proto[pdt_proto['resotype'] != 'euler']
    else:
        pdt_proto2 = pdt_proto

    ylog = 1
    
    for ii, vara in enumerate(varalis):
        print(ii)

        if not mono_data:
            axlin = axarr[ii,:]
        else:
            axlin = axarr.flatten()
            
        
        if ylog:
            ylogsuffix = ", log. scale"
            [a.set_yscale('log') for a in axlin[0:3]]
        else:
            ylogsuffix = ""

        [a.set_xscale('log') for a in axlin]
        
        pdt = copy.deepcopy(pdt_proto2)
        
        pdt = pdt[(pdt['x']    == vara[0]) & (pdt['y'] == vara[1]) & \
                  (pdt['zmax'] == vara[2])]    
        
        pdt = pdt[pdt['h'] <= 100]

        cm     = plt.get_cmap('jet')
        NCOL = len(np.unique(pdt['resotype']))
        colist = [cm(1.*i/NCOL) for i in range(NCOL)] 
        
        for kk , reso in enumerate(np.unique(pdt['resotype'])):

            pdttmp = pdt[pdt['resotype'] == reso]
            X,Y = gf.sort_binom_list(pdttmp['h'],pdttmp['diff_eiko_t'])
            axlin[0].plot(X,np.abs(Y),'-o',label=reso.upper(),c=colist[kk])
            X,Y = gf.sort_binom_list(pdttmp['h'],pdttmp['diff_eiko_s'])
            axlin[1].plot(X,np.abs(Y),'-o',label=reso.upper(),c=colist[kk])
            X,Y = gf.sort_binom_list(pdttmp['h'],pdttmp['diff_eiko_a'])
            axlin[2].plot(X,np.abs(Y),'-o',label=reso.upper(),c=colist[kk])
            X,Y = gf.sort_binom_list(pdttmp['h'],pdttmp['eiko_time'])
            axlin[3].plot(X,np.abs(Y),'-o',label=reso.upper(),c=colist[kk])
        if 0:
            axlin[0].set_ylim(0,np.max(pdt_proto2['diff_eiko_t']))
            axlin[1].set_ylim(0,np.max(pdt_proto2['diff_eiko_s']))
            axlin[2].set_ylim(0,np.max(pdt_proto2['diff_eiko_a']))
            axlin[3].set_ylim(np.min(pdt_proto2['eiko_time']),
                              np.max(pdt_proto2['eiko_time']))
        elif not ylog :
            axlin[0].set_ylim(gf.ylim_easy(pdt['diff_eiko_t']))
            axlin[1].set_ylim(gf.ylim_easy(pdt['diff_eiko_s']))
            axlin[2].set_ylim(gf.ylim_easy(pdt['diff_eiko_a']))
            axlin[3].set_ylim(gf.ylim_easy(pdt['eiko_time']))            
            
        axlin[0].legend(loc=0)
        axlin[1].legend(loc=0)
        axlin[2].legend(loc=0)
        axlin[3].legend(loc=0)
    
        if True: # condtion ii == len(varalis) -1 si on veut les legends que en bas
            axlin[0].set_xlabel('integration step (m), log. scale')
            axlin[1].set_xlabel('integration step (m), log. scale')
            axlin[2].set_xlabel('integration step (m), log. scale')
            axlin[3].set_xlabel('integration step (m), log. scale')

        axlin[0].set_ylabel('time difference (s)'        + ylogsuffix)
        axlin[1].set_ylabel('path length difference (m)' + ylogsuffix)
        axlin[2].set_ylabel('angle difference (deg)'     + ylogsuffix)
        axlin[3].set_ylabel('execution time (s)'         + ', lin. scale')
    
    #    axlin[0].set_ylabel('distance difference (m)')
    #    axlin[1].set_ylabel('path length difference (m)')
    #    axlin[2].set_ylabel('propagation time (s)')
    #    axlin[3].set_ylabel('mean execution time (s)')
        
        coorstr = 'X = ' + str(np.unique(pdt['x'])[0]) + 'm., ' + 'Y = ' + str(np.unique(pdt['y'])[0]) + 'm., Z = ' + str(np.unique(pdt['zmax'])[0]) + 'm.'
    
        if ii == 0:
            axlin[0].set_title('propagation time difference \n' + coorstr)
            axlin[1].set_title('path length difference      \n' + coorstr)
            axlin[2].set_title('emission angle difference   \n' + coorstr)
            axlin[3].set_title('execution time              \n' + coorstr)
        else:
            axlin[0].set_title(coorstr)
            axlin[1].set_title(coorstr)
            axlin[2].set_title(coorstr)    
            axlin[3].set_title(coorstr)    
    
    #    plotdic_h_time['title'] = 'execuction time \n' + 'X = ' + pdt['x'] + 'm., ' + 'Y = ' + pdt['y'] + 'm., Z = ' + pdt['z'] + 'm.'
    #    plotdic_h_t['title'] = 'propagation time difference \n' + 'angle = ' + str(z_ang_tup[1]) + 'deg., ' + 'max. depth = ' + str(z_ang_tup[0]) +'m'
    #    axlin[3].set_title('path length difference \n' + 'angle = ' + str(z_ang_tup[1]) + 'deg., ' + 'max. depth = ' + str(z_ang_tup[0]) +'m'
    
#        axlin[0].set_xscale('log')
#        axlin[1].set_xscale('log')
#        axlin[2].set_xscale('log')
#        axlin[3].set_xscale('log')
#        axlin[3].set_yscale('log')
        
#        y_formatter = matplotlib.ticker.ScalarFormatter(useOffset=False)
#        axlin[2].yaxis.set_major_formatter(y_formatter)    
     
    #fig.set_size_inches(16.53*np.sqrt(2)*0.8,11.69*.5*np.sqrt(2)*0.8)
    #fig.set_size_inches(11.69*np.sqrt(2)*.75,(16.53/3.)*4*.75)

    # petite figure mignone (conne dans article)
    fig.set_size_inches(8.27,8.27)

    #fig.set_size_inches(16.53*np.sqrt(2)*0.8,11.69*.5*np.sqrt(2)*0.8)
    #fig.set_size_inches(11.69*np.sqrt(2)*.75,(16.53/3.)*4*.75)
    fig.set_size_inches(16.53,11.69)

    suptit = 'Comparison of restitued parameters using Eikonal method with different integration approachs compared to the Snell Descartes method as reference in function of the integration step'
    fig.suptitle(suptit)
    fig.tight_layout()
    plt.subplots_adjust(top=0.90)

    pltname = gf.join_improved('_', 'inv','eiko')
    pltpath = os.path.join(plotdir, pltname)
    plt.savefig(pltpath + '.png')
    plt.savefig(pltpath + '.pdf')

    fig , axarr = plt.subplots(len(varalis),4)

###############################################
#      EIKO AVEC D EN ABSISSE
###############################################

if 0:
    plt.ioff()
    for resotype , h in itertools.product(set(pdt_proto['resotype']),
                                          set(pdt_proto['h'])):
        
        if h != 10:
            continue
        
        fig , axlin = plt.subplots(2,2)
        axlin = np.array(axlin.flat)
        pdt   = copy.deepcopy(pdt_proto)

        pdt = pdt[(pdt['resotype'] == resotype ) & (pdt['h'] == h)]
        
        sm = plt.cm.ScalarMappable(cmap='viridis_r', 
                           norm=plt.Normalize(vmin=np.min(pdt['zmax']),
                                              vmax=np.max(pdt['zmax'])))
        sm.set_array(np.unique(pdt_proto['zmax']))
    
    
    #    A =     pdt[(2000 < dplani2) & (dplani2 < 2300)] 
    #    B = dplani2[(2000 < dplani2) & (dplani2 < 2300)]
    #
    #
    #    A =     pdt[(2800 < dplani2) & (dplani2 < 2900)] 
    #    B = dplani2[(2800 < dplani2) & (dplani2 < 2900)]
    #    
    
        pdt = pdt[np.isfinite(pdt['diff_eiko_t'])]
        pdt = pdt[np.isfinite(pdt['diff_eiko_s'])]    
        pdt = pdt[np.isfinite(pdt['diff_eiko_a'])]    
        
        dplani2 = geok.pythagore(pdt['x'],pdt['y']) 
        #h = np.unique(pdt['h'])[0]
    
        axlin[0].scatter(dplani2,pdt['diff_eiko_t'],30,c=sm.to_rgba(pdt['zmax']))
        axlin[1].scatter(dplani2,pdt['diff_eiko_s'],30,c=sm.to_rgba(pdt['zmax']))
        axlin[2].scatter(dplani2,pdt['diff_eiko_a'],30,c=sm.to_rgba(pdt['zmax']))
        axlin[3].scatter(dplani2,pdt['eiko_time']  ,30,c=sm.to_rgba(pdt['zmax']))
    
        axlin[0].set_ylim(gf.ylim_easy(pdt['diff_eiko_t']))
        axlin[1].set_ylim(gf.ylim_easy(pdt['diff_eiko_s']))
        axlin[2].set_ylim(gf.ylim_easy(pdt['diff_eiko_a']))
        axlin[3].set_ylim(gf.ylim_easy(pdt['eiko_time']))
    
        Xlabel = r'radial distance between ' + '\n' + ' source and reciever ($\sqrt{x^2_r + y^2_R}$) (m.)'
        axlin[0].set_xlabel(Xlabel)
        axlin[1].set_xlabel(Xlabel)
        axlin[2].set_xlabel(Xlabel)
        axlin[3].set_xlabel(Xlabel)
    
        axlin[0].set_ylabel('distance difference (m)')
        axlin[1].set_ylabel('propagation time (s)')
        axlin[2].set_ylabel('emission angle (deg)')
        axlin[3].set_ylabel('mean execution time (s)')
        
        coorstr = 'X = ' + str(np.unique(pdt['x'])[0]) + 'm., ' + 'Y = ' + str(np.unique(pdt['y'])[0]) + 'm., Z = ' + str(np.unique(pdt['zmax'])[0]) + 'm.'
        coorstr = ''
        axlin[0].set_title('point position difference' + coorstr )
        axlin[1].set_title('propagation time difference' + coorstr)
        axlin[2].set_title('emission angle difference' + coorstr)
        axlin[3].set_title('execution time' + coorstr)
        
        resotypetitdic = dict()
        resotypetitdic['euler'] = 'Euler\'s'
        resotypetitdic['rk4']   = 'Runge-Kutta 4' 
        resotypetitdic['rkf45'] = 'Runge-Kutta-Fehlberg'
        resotypetitdic['rkdp']  = 'RKDP'     
        resotypetitdic['rkck']  = 'RKCK' 
        resotypetitdic['rk2']   = 'Runge-Kutta 2' 
           
        suptit = 'Comparison of restitued parameters using Eikonal ' + resotypetitdic[resotype] + ' (step = ' + str(h) + 'm) method compared to the Snell-Descartes method as reference \n in function of the distance between the source and the reciever'
    
        fig.suptitle(suptit)
    
    #    y_formatter = matplotlib.ticker.ScalarFormatter(useOffset=False)
    #    axlin[2].yaxis.set_major_formatter(y_formatter)   
        
        axlin[0].ticklabel_format(style='sci', axis='y',scilimits=(0,0),useOffset=False)
        axlin[1].ticklabel_format(style='sci', axis='y',scilimits=(0,0),useOffset=False)
        axlin[2].ticklabel_format(style='sci', axis='y',scilimits=(0,0),useOffset=False)
    
        fig.set_size_inches(16.53,11.69)
            
        fig.tight_layout()
        plt.subplots_adjust(top=0.92)
        import matplotlib as mpl
        cax,kw = mpl.colorbar.make_axes([ax for ax in axlin.flat])
        cax.set_title(r'reciver depth $z_R$' + '\n')
        fig.colorbar(sm, cax=cax)
        
        plotdir = gf.create_dir(plotdir)
        pltname = gf.join_improved('_', 'inv','eiko_2',resotype,h)
        pltpath = os.path.join(plotdir, pltname)
        plt.savefig(pltpath + '.png')
        plt.savefig(pltpath + '.pdf')
        plt.close()
    
###############################################
#      EQUIVALENT
###############################################

if 1:
    figequiv , axarrequiv = plt.subplots(1,3)
    axarrequiv = np.array(axarrequiv.flat)
    sm = plt.cm.ScalarMappable(cmap='viridis_r', 
                               norm=plt.Normalize(vmin=np.min(pdt_proto['zmax']),
                                                  vmax=np.max(pdt_proto['zmax'])))
    sm.set_array(np.unique(pdt_proto['zmax']))
    #figequiv.colorbar(sm)       
    
    A = axarrequiv
    #A = np.insert(A,0,0)
    pdt = copy.deepcopy(pdt_proto)
#    pdt = pdt[(pdt['x']    == vara[0]) & (pdt['y'] == vara[1]) & \
#              (pdt['zmax'] == vara[2])]

    pdt = pdt[(pdt['h'] == 10) & (pdt['resotype'] == 'euler')]

    pdt = pdt[np.isfinite(pdt['diff_equiv_t'])]
    pdt = pdt[np.isfinite(pdt['diff_equiv_s'])]    
    pdt = pdt[np.isfinite(pdt['diff_equiv_a'])]    
              
    dplani2 = geok.pythagore( pdt['x'] , pdt['y'] )
    dplani3 = geok.pythagore( pdt['x'] , pdt['y'] , pdt['zmax'] )
    
    for zzz in np.unique(pdt['zmax']):
        pdtt    = pdt[pdt['zmax'] == zzz]
        dplani4 = geok.pythagore( pdtt['x'] , pdtt['y'] )

        col  = sm.to_rgba(zzz)
        X,Y = dplani4,pdtt['diff_equiv_t']
        X,Y = gf.sort_binom_list(X,Y)
        A[0].plot(X,np.abs(Y),c=col)
        X,Y = dplani4,pdtt['diff_equiv_s']
        X,Y = gf.sort_binom_list(X,Y)
        A[1].plot(X,np.abs(Y),c=col)       
        X,Y = dplani4,pdtt['diff_equiv_a']
        X,Y = gf.sort_binom_list(X,Y)
        A[2].plot(X,np.abs(Y),c=col)


    X,Y = dplani2,pdt['diff_equiv_t']
    A[0].scatter(X,np.abs(Y),30,label='',c=sm.to_rgba(pdt['zmax']))
    X,Y = dplani2,pdt['diff_equiv_s']
    A[1].scatter(X,np.abs(Y),30,label='',c=sm.to_rgba(pdt['zmax']))
    X,Y = dplani2,pdt['diff_equiv_a']
    A[2].scatter(X,np.abs(Y),30,label='',c=sm.to_rgba(pdt['zmax']))
    X,Y = dplani2,pdt['equiv_time']        
    #A[3].scatter(X,Y,30,label='',c=sm.to_rgba(pdt['zmax']))
    
    [a.set_yscale('log') for a in A[0:2]]

    A[0].set_ylim(gf.ylim_easy(np.abs(pdt['diff_equiv_t']),10**-5))
    A[1].set_ylim(gf.ylim_easy(np.abs(pdt['diff_equiv_s']),10**-5))
    A[2].set_ylim(gf.ylim_easy(pdt['diff_equiv_a'],10**-5))
    #A[3].set_ylim(gf.ylim_easy(pdt['equiv_time']))
    
    A[0].set_xlim((0,3500))
    A[1].set_xlim((0,3500))
    A[2].set_xlim((0,3500))
    
    Xlabel = r'radial distance between ' + '\n' + ' source and reciever ($\sqrt{x^2_r + y^2_R}$) (m.)'
    A[0].set_xlabel(Xlabel)
    A[1].set_xlabel(Xlabel)
    A[2].set_xlabel(Xlabel)
    #A[3].set_xlabel(Xlabel)

    A[0].set_ylabel('time difference (s), log. scale')
    A[1].set_ylabel('path length (m), log. scale')
    A[2].set_ylabel('emission angle (deg), lin. scale')
    #A[3].set_ylabel('mean execution time (s)')
    
    coorstr = 'X = ' + str(np.unique(pdt['x'])[0]) + 'm., ' + 'Y = ' + str(np.unique(pdt['y'])[0]) + 'm., Z = ' + str(np.unique(pdt['zmax'])[0]) + 'm.'
    coorstr = ''

    A[0].set_title('propagation time difference' + coorstr)    
    A[1].set_title('path length difference'      + coorstr)
    A[2].set_title('emission angle difference'   + coorstr)
    
    #A[3].set_title('execution time' + coorstr)
    
    suptit = 'Comparison of restitued parameters using equivalent method compared to \n the Snell Descartes method as reference in function of the distance between the source and the reciever'

    figequiv.suptitle(suptit)
    
    y_formatter = matplotlib.ticker.ScalarFormatter(useOffset=False)
    A[2].yaxis.set_major_formatter(y_formatter)   
    figequiv.set_size_inches(0.79*16.53,0.79*11.69/2)
    
#    fig.subplots_adjust(right=0.9)
    figequiv.tight_layout()
    plt.subplots_adjust(top=0.8)
    import matplotlib as mpl
    cax,kw = mpl.colorbar.make_axes([ax for ax in A[1:3].flat],fraction=0.06)
    cax.set_title(r'reciver' + '\n' + r'depth $z_R$' + '\n')
    figequiv.colorbar(sm, cax=cax)
    
    pltname = gf.join_improved('_', 'inv','equiv')
    pltpath = os.path.join(plotdir, pltname)
    plt.savefig(pltpath + '.png')
    plt.savefig(pltpath + '.pdf')
