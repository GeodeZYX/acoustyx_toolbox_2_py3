# -*- coding: utf-8 -*-
"""
Created on Mon Aug  8 11:57:44 2016

230816 DISCONTINUE CAR REINJECTÉ DANS LE AFONCTION EQUIVALENT DE 
L'ACOUCLASS (ENFIN JE CROIS ...)

@author: psakicki
"""

from megalib import *

exp1 = "Grid4Gdic_Interpo3_interp0_20x20_x4100_y4100_ang90_nois1-0__grad0_0__"
exp2 = "Grid4Gdic_Interpo3_interp1_20x20_x4100_y4100_ang90_nois1-0__grad0_0__"
outname = 'Gdic_METEORInterpo3_20' #20 comme la taille de la grille

pathin = '/home/psakicki/THESE/CODES/CodePython/acoustyx_toolbox_2/working/'
exp1 = "Grid4Gdic_Interpo3_interp0_20x20_x4100_y4100_ang90_nois1-0__grad0_0__"
exp2 = "Grid4Gdic_Interpo3_interp1_20x20_x4100_y4100_ang90_nois1-0__grad0_0__"
outname = 'Gdic_METEORInterpo3_20' #20 comme la taille de la grille

D1 = acls.give_me_the_path(os.path.join(pathin,exp1),exp1)
D2 = acls.give_me_the_path(os.path.join(pathin,exp2),exp2)

Gdic = dict()

for ipxp in range(np.max(list(D1['P'].keys()))):
    ipxp += 1
    Temi1 = np.array(D1['P'][ipxp]['t']['T_emi_clean'])
    Temi2 = np.array(D2['P'][ipxp]['t']['T_emi_clean'])
    
    dT = Temi1 - Temi2
    dTraw = np.array(dT)
    #dT = Temi1
    
    X = np.array(D1['P'][ipxp]['t']['X_emi_clean'])
    Y = np.array(D1['P'][ipxp]['t']['Y_emi_clean'])


    boolmad = geok.outiler_mad(dT)[1]

    # Refabrication des NaN
    for iTemi , Temi in enumerate((Temi1,Temi2)):
        
        print('PXP' , ipxp , 'Temi' ,  iTemi) 
        
        
        Temi[np.logical_not(boolmad)] = np.nan
        
        boolgood = np.logical_not(np.isnan(Temi))
        boolbad  = np.logical_not(boolgood)
        
        if np.sum(boolbad) == 0:
            continue

        dTssnan = dT[boolgood]
        Xssnan  = X[boolgood]
        Yssnan  = Y[boolgood]

        Xnan  = X[boolbad]
        Ynan  = Y[boolbad]
        
        print('INFO : Xnan , Ynan')
        print(Xnan)
        print(Ynan)
        
        dTnew = []
        for xnan , ynan in zip(Xnan,Ynan):
            Y4I = Yssnan[Yssnan == ynan]
            X4I = Xssnan[Yssnan == ynan]
            dT4I = dTssnan[Yssnan == ynan]

            II = scipy.interpolate.interp1d(X4I,dT4I,fill_value="extrapolate",
                                            kind='linear', bounds_error=0)
            
            dTnew.append(II(xnan))
        dTremake = np.stack(dTnew)
            
        
        
#            try:
#                II          = scipy.interpolate.interp2d(Xssnan,Yssnan,dTssnan)
#            except:
#                print "ca chie avec l'interpo"
#                return Xssnan,Yssnan,dTssnan
#                
#            dTremake    = np.diag(np.stack(II(Xnan,Ynan)))
#            print 'INFO : dTremake'
#            print dTremake
        
            
        print('INFO : dTremake')
        print(dTremake)
        
        print('INFO : dT[boolbad]')
        dT[np.squeeze(np.argwhere(boolbad))] = dTremake
        print(dT[boolbad])
    # Fin de refabrication des NaN
    try:
        Xuniq = np.unique(np.round(np.array(X),decimals=7))
        Yuniq = np.unique(np.round(np.array(Y),decimals=7))
        dTreshap = np.reshape(dT,(len(Xuniq),len(Yuniq)))
        
    except:
        print('ERR : ça chie')
    I = scipy.interpolate.RegularGridInterpolator((Xuniq,Yuniq),
                                                  dTreshap,bounds_error = False,
                                                  fill_value=False)
    Gdic[ipxp] = I
    Gdic[str(ipxp) + 'dT'] = dT

    print('INFO : ipxp , dT')       
    print(ipxp , dT)
    
if pathout and namedicout:
    outpath = genefun.pickle_saver(Gdic,pathout,namedicout)
    
print("INFO : output in : ") 
print(outpath)
    
plt.plot(dTraw,'x')
plt.plot(dT,'+')

