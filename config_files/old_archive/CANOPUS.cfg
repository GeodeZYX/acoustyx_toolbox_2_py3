[paths]
# gene_path : is the general path where the experience folder is stored
gene_path         = '/home/psakicki/THESE/1705_CANOPUS/O_files/' 
# alternat_ssp_path : path for an alternative Sound Speed Profile, almost discontinued
alternat_ssp_path = '/home/psakicki/Documents/CODES/acoustyx_toolbox_2/exemple/SSP/SSP_NOAA_dep5781_20050827000000'

[experience]
multiexp_mode     = "single" 
# single / list / prefix : see below for details

# single mode : name of the experience
exp = 'Detection14mai_wo_clean'
exp = 'Detection15mai'
exp = 'Detection14mai'

# list mode : a list of experience name, if you want to run several experiments with the same parameters in a batch mode
exp_lis = ['Detection14mai','Detection15mai']    

# prefix mode : analog to list, but using a prefix to list the experiences
expprefix    = 'Detection'

# A suffix can be added (shall not used)
expdirsuffix = ''

# You can specify a custom name for the experiment run
# which will be added in the output files name
# to describe the specific configuration of the run
exp_custom_name = 'titi'

# choice of the experiment file type 
mnop_files_ext = 'auto' 
# 'auto' or 'M', 'N', 'O' & 'P'
# M N files are discontinued, O is for real campaigns, P is for simulation

[processing_mode]
batch_mode         = 1         # discontinued
force_mode         = 0         # if several experiences, if something goes wrong, pass to the next experience
force_mode_reading = 0         # if several experiences, if the data reading fails, pass to the next experience
purge_mode         = 0         # clean the experience folder by removing all existing results, logs, plots ... (but keeps input data), purge_prelim_mode shall be prefered
purge_prelim_mode  = 0         # if several experiences, clean all the folders at the begining, best than the previous one
sigma_batch_mode   = 1         # discontinued
plot_mode          = 1         # plot residuals, histograms and error ellipses (the last plot is experimental)

[processing_options]
with_barycenter            = 1 # Use this mode for a direct determination of the beacons array barycenter coordinates and associated formal sigmas
with_bl                    = 1 # If avaiable, use distance information between the seafloor beacons
                               # data are stored in a .B.dat file
                               
with_cleaning              = 1 # Activate cleaning with residual (V) standard dev : keeps the ping if v_ping < cleaning_coef * std(V) (check the value of the cleaning_coef variable below ! usually 3sigmas)
with_v_4_p_reinject        = 0 # use residuals of the previous iteration as weights for the new one

with_mono_z                = 0 # Estimate the same Z (depth) for all the beacons (experimental, for simulation)
with_zmaster               = 0 # Use depth differences between beacons, as least square observables (experimental, for simulation)
with_dzcst                 = 0 # Use depth differences between beacons, as constants (experimental, for simulation)
                               # the ref beacon is the first one
                               # Depth informations are in the .O/P.dat file (containing the pings)
                               # and is taken from the apriori depth of each beacon (in the line 'pxp_coords')
# Some modes are impossible :
#     with_mono_z and with_zmaster 
#     with_zmaster and not with_bl
#     with_dzcst and with_zmaster

with_noising_apriori       = 0 # This part shall be activated only for simulation, it activates or not the [sigmas_noise_apriori] part below, in order to perturbate the apriori

with_time_window           = 0 # apply a time window, using start/end or start_end_multi (see below)
with_specific_timwin_bool  = 0 # discontinued

with_jackknife             = 1 # Apply a Jack Knife, i.e. picking randomly some pings in a full set. 
                               # The behavior of the Jack Knife can be changed by the variable 
                               # jk_rand_seed (an int which controls the random selection), 
                               # and the keep_ratio (ranging between  0 & 1) in the [values] section
with_invert_jk             = 0 # Invert the selection done by the Jack Knife

with_fb_mode               = 1 # Activate the forward/backward mode : using a different raytracing for the surface=>seafloor & the seafloor=>surface shoot (this mode is more accurate so shall be ON) 

# ****** the following options are discontinued
with_old_style             = 0 # If True, select the F or the B as the time of ping, If false time of ping = TWTT/2 (only for debug), WORKS ONLY IF with_fb_mode == False
with_backward_select       = 0 # use the backward raytracing (only for debug), WORKS ONLY IF with_fb_mode == False and_with_old_style == True !!!!
# with_fb_mode take as input the Two way travel time (TWTT), and not the TWTT/2
# with_fb_mode is False, then it is the former processing way using TWTT/2, and with_old_style allows to get TWTT/2 in data with specific keywords
# Nevertheless, with_fb_mode = True shall be used now
# ******
with_ssp_bilin             = 0 # Use a bilinear Sound Speed (experimental & unstable)
with_decimate_ssp          = 1 # Decimate the SSP using the IAPSO 1936 convention (enhance calc speed, so recommended)
with_alternat_ssp          = 0 # Using an alternative SSP, defined by the alternat_ssp_path ([paths] section)
with_smart_ssp             = 0 # use SSPs in a dict (experimental, very specific case)
with_munk_ssp              = 1 # use the Munk generic sound speed profile instead of the real one

with_print_simu_infos      = 0 # Only True for simulations : print in the log file comparisons between the Least Square Inversion results & real positions

[values]
jk_rand_seed       = 1452      # Mersenne random twister for the Jack Knife selection 
keep_ratio         = 0.1       # keeping 10% for the Jack Knife
dX_sum_stop        = 10**-5    # while the coordinates adjustement absolute values sum is above dX_sum_stop, continue the iterations
iitermax  = 4                  # nb of iteration
nbproc    = 6                  # nb of processors
cleaning_coef = 3              # see with_cleaning option (cleaning_coef = 0 means no cleaning)
h         = 0                  # The step for numerical differentiation. If h=0 (recommended), then h = x sqrt(machine ε) [Press et al. 1988]

[time_window]
time_window_mode = 'multi'  # single / multi 
# with_time_window option ([processing_options] section) shall be activated
# start & end are defined as [yyyy,mm,dd,hh,mm,ss] 

# start & end simple
start  = [2015,6,22,1]
end    = [2015,6,22,2]

start  = [2015,6,21,20]
end    = [2015,6,22,1]

start  = [2015,6,21,1]
end    = [2015,6,22,5]

start  = [1970,1,2]
end    = [2038,1,1]

start  = [1970,1,2]
end    = [2038,1,1]

start  = [2017,5,14,0]
end    = [2017,5,14,24]

start  = [2017,5,15,11]
end    = [2017,5,15,13]

start  = [2017,5,15,11]
end    = [2017,5,16,03]

# start & end multi
#start_end_multi = [[[start1],[end1]],[[start2],[end2]],[[start3],[end3]],...]

start_end_multi = [[[2015,6,21,20],[2015,6,21,22]],[[2015,6,21,22],[2015,6,22,00]],[[2015,6,22,00],[2015,6,22,02]],[[2015,6,22,02],[2015,6,22,4]]]
start_end_multi = [[[2015,6,21,20],[2015,6,21,21]],[[2015,6,21,21],[2015,6,21,22]],[[2015,6,21,22],[2015,6,21,23]],[[2015,6,21,23],[2015,6,22,0]],[[2015,6,22,0],[2015,6,22,1]],[[2015,6,22,0],[2015,6,22,1]],[[2015,6,22,1],[2015,6,22,2]],[[2015,6,22,2],[2015,6,22,3]],[[2015,6,22,3],[2015,6,22,4]],[[2015,6,22,4],[2015,6,22,5]]]
start_end_multi = [[[2017,5,14,8],[2017,5,14,10]],[[2017,5,14,10],[2017,5,14,12]],[[2017,5,14,12],[2017,5,14,14]],[[2017,5,14,14],[2017,5,14,16]],[[2017,5,14,14],[2017,5,14,18]]]
start_end_multi = [[[2017,5,15,11],[2017,5,15,15]],[[2017,5,15,15],[2017,5,15,19]],[[2017,5,15,19],[2017,5,15,23]],[[2017,5,15,23],[2017,5,16,03]]]

start_end_multi = [[[2017,5,14,10],[2017,5,14,14]],[[2017,5,14,12],[2017,5,14,16]],[[2017,5,14,14],[2017,5,14,18]]]

start_end_multi = [[[2017,5,15,21],[2017,5,16,00]]]

start_end_multi = [[[2017,5,14,10],[2017,5,14,14]],[[2017,5,14,12],[2017,5,14,16]],[[2017,5,14,14],[2017,5,14,18]]]
start_end_multi = [[[2017,5,15,11],[2017,5,15,15]],[[2017,5,15,13],[2017,5,15,17]],[[2017,5,15,15],[2017,5,15,19]],[[2017,5,15,17],[2017,5,15,21]],[[2017,5,15,19],[2017,5,15,23]],[[2017,5,15,21],[2017,5,16,00]]]

[sigmas_weights]
sigma_defo_asm     = 10**-6 # weights for the acoustics ping
sigma_defo_bl      = 10**-5 # weights for the baseline length
sigma_defo_zmaster = 10**-3 # weights for the depth differences

[sigmas_noise_apriori]
# the with_noising_apriori option shall be activated
sigma_pxp_apri = 0      # perturbate the apriori positions of the PXP  (in meters)
sigma_dz_apri  = 0      # perturbate the depth differences observations, only for the with_dzcst option (in meters)
sigma_bl_apri  = 0      # perturbate the baseline length observations  (in meters)
sigma_z_apri   = 1      # only for the with_mono_z option, perturbate the zmono apriori (in meters)

# The Mersene twisters for the noise on the apriori
# It allows to generate the same noise on differents runs
# (but changing the twister change the noise)
kmeta_pxp_apri = 10 # by internal convention, must be a multiple of 10 (10,20,30,40...)
k_z_apri       = 42
k_dz_apri      = 1789
k_BL_apri      = 420 
