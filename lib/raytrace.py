# -*- coding: utf-8 -*-
# Autogenerated with SMOP version 0.23
# main.py /home/psakic01/THESE/CodeMk4/fonctions/raytrace/raytrace_SnellDesc.m

from geodezyx import *                   # Import the GeodeZYX modules
from geodezyx.externlib import *         # Import the external modules
from geodezyx.megalib.megalib import *   # Import the legacy modules names



import numpy as np
import warnings
from scipy.io import loadmat,savemat
from SSP import *
import time
import os
import acouclass as acls
import bisect
#import genefun
import multiprocessing as mp
import matplotlib as mpl
import matplotlib.pyplot as plt
from scipy.optimize import  curve_fit
import scipy.interpolate as scipyinterp
import sys

sys.dont_write_bytecode = True
warnings.simplefilter('always', UserWarning) # toujours printer les erreurs

def munk(zmax,pas=1):
    z = np.arange(0,zmax,pas)
    return z , munk_fct(z)


def raytrace_ultimate(xo,zo,theta0,tt,zz,cc):

    """
     A function to raytrace through a sound speed profile to a given time.

     *Val Schmidt
     *Center for Coastal and Ocean Mapping / Joint Hydrographic Center
     *University of New Hampshire
     *2009


     Arguments:
       xo:      starting horizontal coordinate of the ray in meters
       zo:      starting vertical coordinate of the ray in meters
       theta0:  starting angle of the ray in degrees
       tt:      max travel time of the ray in seconds
       zz:      vertical coordinates of the sound speed profile (+ down)
       cc:      sound speed measurements at zz locations
       plotflag: Boolean flag for auto plotting result (optional) default is 0.

     Output:
       xxf:       horizontal coordinates of the ray path
       zzf:       vertical coordinates of the ray path
       ttf:       actual travel time of the ray in seconds
       ddf:       distance the ray traveled

     Raytrace will trace the path sound will travel through a medium with an
     isotropic horizontal sound speed profile and a vertical sound speed
     profile given by (zz,cc) from a point (xo,zo) and departing at an angle
     theta0 for a time of tt seconds. The path is returned in vectors x and z.
     The actual time of travel is returned in t, which may be slightly greater
     that tt. The sound speed profile should include a measurement at the
     surface (zz = 0). If it does not, the profile will be extended to the
     surface by replicating the first measurement there.

     In addition to the above, raytrace() handles caustics (when rays bend
     through horizontal) and reflections off the surface (z=0) and bottom
     which is taken to be at the maximum depth measurement in the sound speed
     profile. The bottom is assumed to be flat. Reflections up to a maximum
     number (MAXBOUNCES) is supported. MAXBOUNCES is hard-coded into the
     function. Decreasing MAXBOUNCES will reduce the memory required for
     calculations when many reflections are not needed.

     EXAMPLE:

     Trace a ray for 120 seconds starting from 0 m depth at a 5 degree down
     angle through a sound speed profile that has a value of 1520 at the
     surface, decreases with a gradient of -0.05 m/s /m to 750 m, and then
     increases with a gradient of 0.014 m/s /m to a maximum depth of 5000 m.

     Setup the sound speed profile
     zz = 0:1:5000;
     cc = 1520 + [zz*-.05];
     cc(751:end) = cc(750) + (zz(751:end)-zz(750))*.014;
      Conduct the raytrace and plot result
     [x z t d] = raytrace(0,0,5,120,zz,cc,true);

     Theory: Ray tracking through linear gradients
     Acoustic energy (sound) refracts when passing through media of varying
     sound speed. A simple and common model for this refaction is presented in
     Principles of Underwater Sound and was recently elucidated in a sprint
     2009 class on underwater acoustics tought at the University of New
     Hampshire by Dr. Tom Weber. In this model, the sound speed variations are
     approximated by piecewise linear gradients. Under this assumption, sound
     travels through the qth layer as an circular arc whose radius is given by

     Rc = -1/g(q) c(q)/cos(theta(q))


     where g(i) is the gradient in the layer, c(i) is the sound speed at the
     entry point of the ray in the layer, and theta(i) is the angle of the ray
     when entering the layer measured with respect to the horizontal.


          '  <---acoustic ray path
             '
    ------------'------------------------------c(q)-------------
     |            '   <-- theta(q)
     |              /'
     dz            /   '           layer of gradient, g = (c(q+1)-c(q) )/dz
     |            /     '
     |          Rc       '
    -------------------------------------------c(q+1)-------------
               <---dx---->'  <--theta(q+1)
                           '
                            '

     Without going into details, the following may be derived from the image
     above:

     dx(q) = Rc( sin(theta(q+1)) - sin(theta(q)))
     dz(q) = Rc( cos(theta(q))) - cos(theta(q+1)))


     Give a vertical step, dz, one may then calculate the exiting angle of the
     ray wrt the horizontal with

     theta(q+1) = acos( cos(theta(q) ) - dz(q)/Rc);


     The time spent traveling along the ray in the layer is given by
     integrating the path length divided by the sound speed. This can
     be expresses as an integral between incoming and outgoing angles as

     Int(theta(q),theta(q+1)) -Rc / c dtheta
     or
      - Int(theta(q),theta(q+1)) 1/( g * cos(theta) ) dtheta


     Evaluating this integral gives the following:

     dt = -2/g(q)*( atanh(tan(theta(q+1)/2)) - atanh(tan(theta(q)/2)) );


     The distance traveled along the ray within a layer is simply this time
     times the mean sound speed in that layer.

     d = dt * (cc(q)+g(q)/2)

     References:
       *Classs Notes from Underwater Acoustics (Dr. Tom Weber) Spring 2009
         University of New Hampshire's Center for Coastal and Ocean Mapping
       *Principles of Underwater Sound, 3rd Edition (Urick, 1983)

    NOTA PERSO :
    OUTPUT : x , z , t , d , ttt_corr
    160929 : Le principe c'est que le RT va 'un peu plus loin',
             puis est rammenée à la bonne valeur
             Les outpuis sont les valeurs corrigées
    """

    zz = np.array([float(e) for e in zz])
    cc = np.array([float(e) for e in cc])

    if genefun.is_not_iterable(theta0):
        theta0 = np.array([theta0])

    m = 0

    # Extend the sound speed profile to the surface
    if zz[0] != 0:
        zz = np.insert(zz , 0 , 0)
        cc = np.insert(cc , 0 , cc[0])


    MAXBOUNCE = 20
    Nsvp = len(zz)
    zzend = zz[-1]

    dz = np.diff(zz)
    dc = np.diff(cc)

    theta0[m] = 90 - theta0[m]

    if theta0[m] < 0 and zo > 0:
         z = np.flipud(zz)
         zzz = np.concatenate((np.array([zz[0]])  , zz[0]  + np.cumsum(np.flipud(dz))))
         ccc = np.concatenate((np.array([cc[-1]]) , cc[-1] - np.cumsum(np.flipud(dc))))
         mult = 1
    else:
        z = zz
        zzz = np.concatenate((np.array([zz[0]]) , zz[0] + np.cumsum(dz)))
        ccc = np.concatenate((np.array([cc[0]]) , cc[0] + np.cumsum(dc)))
        mult = -1

    dzo = dz


    while np.abs(zzz[-1]) < MAXBOUNCE*zzend:
        if mult==-1:
            if theta0[m] < 0:  # initial angle above horizontal
                zzz = np.concatenate((zzz , zzz[-1] + np.cumsum(np.flipud(dz))))
            else:              # initial angle below horizontal
                zzz = np.concatenate((zzz , zzz[-1] + np.cumsum(np.flipud(dz))))

            ccc = np.concatenate((ccc , ccc[-1] + mult*np.cumsum(np.flipud(dc))))
        else:
            if theta0[m] < 0:  # initial angle above horizontal
                zzz = np.concatenate((zzz , zzz[-1] + np.cumsum(dz)))
            else:            # initial angle below horizontal
                zzz = np.concatenate((zzz , zzz[-1] + np.cumsum(dz)))

            ccc = np.concatenate((ccc , ccc[-1] + mult*np.cumsum(dc)))

        z   = np.concatenate((z , z[-1] + mult*np.cumsum(np.flipud(dzo))))
        dz  = np.flipud(dz)
        dzo = np.flipud(dzo)

        mult = mult * -1   # If we were going up, go down after reflection.
                           # If we were going down, go up after reflection.



    # Start with the standard definitions.
    dz = np.diff(zzz)                   # depth steps
    g  = np.diff(ccc)/dz                # sound speed gradient

    # starting index (set to depth closes to zo)
    idx = np.argwhere(np.abs(z[0:Nsvp] - zo) == np.min(np.abs(z[0:Nsvp] - zo)))
    q = idx[0]
    qstart = q

    # Initialize variables
    theta = np.ones(len(dz)) * np.nan
    theta[q[0]] = np.abs(theta0[m]) * np.pi/180

    x  = np.ones(len(z)) * np.nan
    dx = np.ones(len(z)) * np.nan

    x[q] = xo

    t = 0                     # cumulative travel time.
    d = 0                     # cumulative travel distance.
    ttt=[t]

    while t < tt:

        if q > len(g):
            print("ERR : PANIC")
            break

        # Handle constant 0 gradient (no refraction)
        if g[q] == 0:
            theta[q+1] = theta[q] # If there's no gradient, the angle doesn't change.
            if theta[q] == 0:
                dx[q] = np.abs(dz[q])  # For horizontal ray, just extend along horizontal.
            else: # Otherwise, step in straight line along ray angle.
                # The abs value here handles negative launch angles when dz may
                # be postive or negative because of the method in which the ssp
                # has been extended.
                dx[q] = np.abs(dz[q] / np.tan(theta[q]))

            dd = np.sqrt(dx[q]**2 + dz[q]**2)
            dt = dd/ccc[q]

        else:

            # Calculate radius of curvature.
            Rc = -1/g[q] * ccc[q]/np.cos(theta[q])


            # Calculate angle leaveing depth step from angle entering depth
            # step and radius of curvature of ray-path.
            theta[q+1] = np.arccos( np.cos(theta[q]) - dz[q]/Rc)

            # When we go through a caustic we get a complex angle, so we catch
            # and reflect the ray.
            if np.imag(theta[q+1]) != 0:
                theta[q+1] = -theta[q]

                # We need to rejig zzz,ccc, dz, z and g
                # When you are going down and there's a caustic you start
                # to go back up. We need to find the index of the extended
                # synthetic sound speed profile that matches the sound
                # speed at the caustic so we can omit the portion of the
                # sound speed profile where we are to the bottom and back
                # up to our caustic locaiton. That's what this next find
                # statement does.
                #tmp = find(ccc([q+1]:end) == ccc[q])

                A = np.abs(z[(q+1):(q+2*len(cc))] - z[q])
                itmp = np.argwhere(np.min(A) == A)[0][0]

    #                # I feel like all this shifting of the ssp to handle
    #                # caustics should be more easibly done by simply jumping to
    #                # the index in the sound speed profile for the next bounce.
                ccc    = np.concatenate((ccc[0:q] , ccc[(q + itmp):-1]));
                zshift = zzz[q+itmp + 1] - zzz[q]
                zzz    = np.concatenate((zzz[0:q] , zzz[(q + itmp):-1] - zshift))
                z      = np.concatenate((  z[0:q] ,   z[(q + itmp):-1]))
                dz     = np.diff(zzz)
                g      = np.diff(ccc)/dz
                dx[q]  = 0
                dt     = 0
                dd     = 0
            else:
                ## Calculate the dx distance and travel time.
                # The geometry is different if the incident angle is above
                # or below the horizontal. So we catch this and do teh
                # appropriate calculation.
                   # dx[q] =abs( Rc * ( sin(theta[q+1]) - sin(theta[q]) ))
                   # dt = abs(-2/g[q]* ...
                   #     ( atanh(tan(theta[q+1]/2)) - atanh(tan(theta[q]/2)) ))

                if theta[q] > 0:
                    dx[q] = Rc * ( np.sin(theta[q+1]) - np.sin(theta[q]) )
                    dt = -2/g[q]* \
                        ( np.arctanh(np.tan(theta[q+1]/2)) - np.arctanh(np.tan(theta[q]/2)) )
                else:
                    dx[q] = np.abs(Rc * -( np.sin(theta[q+1]) - np.sin(theta[q]) ))
                    dt = -2/g[q]* \
                        ( np.arctanh(np.tan(theta[q+1]/2)) - np.arctanh(np.tan(theta[q]/2)) )

                dd = dt * (ccc[q] + g[q]/2)   # total distance traveled.

        t = t + dt             # total travel time.
        ttt.append(t)             # time series of travel time values
        x[q+1] = x[q] + dx[q]  # x coordinte of ray
        d = d + dd             # distance traveled by ray
        q = q+1                # increment counter


    # Pull out the data.
    x = x[np.logical_not(np.isnan(x))];
    z = z[qstart[0] : (qstart+len(x))[0]]

    corrector = (tt - (t-dt))/dt

    x[-1] = x[-2]+(x[-1]-x[-2]) * corrector
    z[-1] = z[-2]+(z[-1]-z[-2]) * corrector
    t = (t-dt) + dt*corrector # this just sets t == tt
    ttt_corr = np.array(ttt)
    ttt_corr[-1] = t

    return x , z , t , d , ttt_corr



def raytrace_SnellDesc(Zinp, Cinp, theta, zmax, mode='light',severe=True):
    """
     Penser à utiliser raytrace_SD1_frontend en priorité
     Mais, à la difference de la SD3, c'est que cette dernière (la SD1)
     ne gère pas les rebonds

     La première profondeur ( Z(1) ) doit être zero (la surface)
     (extrapolation sinon a prévoir)

     ICI theta est FIXE, si recherche de theta : raytrace_seek

     Basé sur Chadwell 2010 , p 175
     ENTREE :
     Zinp, Cinp : Sound Speend Profile (inp pour input)
     theta : compté dans le sens trigo, l'origine est
             la verticale orientée vers le bas, en degré
             tir vers le nadir,  theta = 0
             tir vers l'horizon, theta = 85
             (dans le cas classique "up to down" il est donc > 0)
     zmax : la profondeur maxi ou on effectue le Ray tracing
            Si = 0, ray tracing pout tout la colonne Z
     mode : 'light' ou 'full' : light (par def) ne calcule que Dx et Dt
     severe : lève une exception si qqch ne va pas
     SORTIE :
     Z : Profondeur [ 0 ,zmax ] (frontière de couche, taille N)
     C : Vitesse [ 0 ,zmax ] (frontière de couche, taille N)
     Dx : Déplacement en plani (couche, 0 + taille N-1)
     Dt : Temps de propagation par couche (couche, taille 0 + N-1)
     G : gradient dans chaque couche (couche, taille N-1)
     A : angle d'incidence (frontière de couche, taille N)
             avec A(1) = theta
     R : Rayon de courbure (couche, taille 0 + N-1)
     S : longeur efferctive de l'arc pour chaque couche (couche, taille 0 +
     N-1) (approche de Yang)
     Ds : une autre approche de calcul de l'arc tq décrite dans Lurton
          normalement egale à la precedente mais implementée en 201602
     NB : Dx Dt et R S : premier elt = 0 (pour coincider avec les autres vecteurs)
     0) test si zmax > max(Z)
    """
    tic = time.time()

    if (mode != 'full' and mode != 'light'):
        mode = 'full'

    if np.any(np.abs(np.diff(Zinp)) < 10**-4):
        raise Exception('ERR : le pas de Z est trop petit, risque de gradient nul')

    if zmax > np.max(Zinp):
        if severe:
            raise Exception(" zmax > max(Z) ")
        else:
            print('WARN : zmax > max(Z) => extrapolation de C')
            print('theta',theta,'zmax',zmax)
            Z, C = SSP_extrapolate(Zinp, Cinp, zmax, 100) # nargout=2

    else:
        Z = Zinp.copy()
        C = Cinp.copy()
    # 00) fabrication de Z avec zmax pour element maxi, et d'un C interpolé
    # correspondant
    if zmax != np.max(Z) and zmax != 0:
        # warnings.warn("ATTENTION : zmax != max(Z) => decoupage de Z et C \
        #\n pensez à le faire en amont ")
        try:
            Z, C = SSP_cut(Z, C, zmax) # nargout=2
        except:
            print('ERR : raytrace_SnellDesc : something very weird is happening', end=' ')
            print('     Z, C & zmax are printed below', end=' ')
            print(Z , C , zmax)

    # 1) recherche du gradient b de chaque couche => interpolation linéaire
    n = max(Z.shape)
    m = max(Z.shape) - 1
    G = np.empty(shape=(m), dtype='float64')
    G = (C[1:m+1] - C[0:m]) / (Z[1:m+1] - Z[0:m])

    # 2) définition de k = cos(theta)/c => Invariant de Snell Descartes
    theta = np.deg2rad(theta)
    k = np.cos((np.pi / 2) - theta) /C[0]
    #k2 = np.sin(theta)/C[0]

    # 3) integration des distances et temps
    Dt = np.empty(shape=(m), dtype='float64')
    Dx = np.empty(shape=(m), dtype='float64')

    Dx = (1 / (k * G)) * (np.sqrt(1 - k**2 * C[0:m]**2 ) - np.sqrt(1 - k**2 * C[1:m+1]**2))
    Dt = (1/G) * np.log( ((C[1:m+1])/(C[0:m])) * ((1 + np.sqrt(1 - k**2 * C[0:m]**2)) /(1 + np.sqrt(1 - k**2 * C[1:m+1]**2))) )

    Dx = np.insert(Dx,0,0)
    Dt = np.insert(Dt,0,0)

    Ds = (1/ (k*G)) * (np.arccos(k * C[0:m]) - np.arccos(k * C[1:m+1]))

    if mode == 'full':
        # 4) Fabrication du vecteur des angles
        A = np.empty(shape=(n), dtype='float64')
        A = np.rad2deg(np.arcsin(k * C))

        # 5) fabrication du rayon de courbure pour chaque couche
        R = np.empty(shape=(m), dtype='float64')
        R = - 1.0 / (k * G)
        R = np.insert(R,0,0)

        # 6) fabrication de la longeur de l'arc pour chaque couche
        # d'après Yang : Si = Ri (theta_i - theta_i+1)
        S = np.empty(shape=(m), dtype='float64')
        S = R[1:m+1] * ( np.deg2rad(A[0:m]) - np.deg2rad(A[1:m+1]) )
        S = np.insert(S,0,0)
    else :
        A = np.nan
        R = np.nan
        S = np.nan

    toc = time.time()
    extime = toc-tic

    #print ("temps execution de SSP SnellDesc : %f" %(extime) )
    #print ("")

    return Z, C, Dx, Dt, G, A, R, S, Ds , extime

def raytrace_SnellDesc_dc(Zinp,Cinp,theta,zmax,dc):
    Cinp = np.array(Cinp) + dc
    raytrace_SnellDesc(Zinp,Cinp,theta,zmax)
    return Z, C, Dx, Dt, G, A, R, S, extime


def  raytrace_SnellDesc3(Zinp,Cinp,zstart,zmax,tmax,theta,tcut = 0.1,
                         verbose = True):
    """ Penser à utiliser raytrace_SnellDesc_frontend en priorité
        (la raytrace_SD1_frontend pour être précis)

     LA FONCTION 3 EST LENTE ET COMPLIQUÉE ...
     PRIVILEGIER LA SD1 ...
     Mais la SD3 gère les rebonds

     La première profondeur ( Z(1) ) doit être zero (la surface)
     (extrapolation sinon a prévoir)

     amélioration de la vers 2
     avec temps t exacts sous forme de points

     ICI theta est FIXE, si recherche de theta : raytrace_seek

     Basé sur Chadwell 2010 , p 175

     ENTREE :
         Zinp, Cinp : Sound Speend Profile (inp pour input)

         theta : angle d'incidence suivant la surface,
                 compté dans le SENS TRIGO,
                 en degrés
                 (si rayon tracé "up to down" => theta est < 0)

         zmax : la profondeur maxi ou on effectue le Ray tracing
                Si = 0, ray tracing pout tout la colonne Z

         tcut : pas pour des Dx et Dz avec Dt constant (données du tuple "Round")
            inutile en l'état (avait été utilisé pour créer des
            "front d'ondes" pour les simu du RT à Marmara
            en octobre 2014 (mais commentaire d'avril 2015)

     SORTIE :
         Z : Profondeur [ 0 ,zmax ] (frontière de couche, taille N)

         C : Vitesse [ 0 ,zmax ] (frontière de couche, taille N)

         Dx : Déplacement en plani (couche, 0 + taille N-1)

         Dt : Temps de propagation par couche (couche, taille 0 + N-1)

         G : gradient dans chaque couche (couche, taille N-1)

         (Dzround,Dxround,Dtround) : le tuple "Round"

     NB : Dx Dt et R S : premier elt = 0 (pour coincider avec les autres vecteurs)
     0) test si zmax > max(Z)
    """
    tic = time.time()

    if np.any(np.abs(np.diff(Zinp)) < 0.01):
        raise Exception('ERR : le pas de Z est trop petit, risque de gradient nul')

    if zmax > np.max(Zinp):
        warnings.warn('WARN : zmax > max(Z) => extrapolation de C')
        Z, C = SSP_extrapolate(Zinp, Cinp, zmax, 100) # nargout=2
    else:
        Z = Zinp.copy()
        C = Cinp.copy()
    # 00) fabrication de Z avec zmax pour element maxi, et d'un C interpolé
    # correspondant
    if zmax != np.max(Z) and zmax != 0:
        # warnings.warn("ATTENTION : zmax != max(Z) => decoupage de Z et C \
        #\n pensez à le faire en amont ")
        Z, C = SSP_cut(Z, C, zmax) # nargout=2
    # recherche du gradient b de chaque couche => interpolation linéaire
    n = len(Z)
    m = len(Z) - 1
    G = np.diff(C) / np.diff(Z)

    # définition de k = cos(theta)/c => Invariant de Snell Descartes
    theta = np.deg2rad(theta)
    k = np.cos( theta) /C[ bisect.bisect_left(Z,zstart) ]

    # Définition de la direction du rayon
    if theta >= 0 :
        uptodown = True
    else:
        uptodown = False

    tcutlist = np.arange(0,tmax,tcut)[1:]
    Dx,Dt,Dz = np.zeros(1),np.zeros(1),np.array([zstart])
    Dxround,Dtround,Dzround = np.empty(0),np.empty(0),np.empty(0)

    kriter = 0
    kritermax = 10000

    # integration des distances et temps

    while np.abs(np.sum(Dt) - tmax) > 10**-7  and kriter < kritermax:

        zactual = np.sum(Dz)

        # Inversion du sens si on rencontre le fond ou la surface
        if zactual >= zmax:
            uptodown = not uptodown
        elif zactual <= 0:
            uptodown = not uptodown

        if uptodown:
            i = bisect.bisect_left(Z,zactual)
            try:
                g = G[i]
            except IndexError:
                print('IndexError... Clue : are you sure your init. theta \
                is in deg. & in the good direction ?')
                print('e.g. for a up to bottom ray, theta must be neagtive')
                return None
            c1 = C[i]
            c2 = C[i+1]
            mult = 1
        else:
            i = bisect.bisect_left(Z,zactual) -1
            g = G[i]
            c1 = C[i+1]
            c2 = C[i]
            mult = -1

        # Traitement dans le cas de reflexion
        coeflimit = k ** 2 * c2 ** 2
        if coeflimit >= 1:
            uptodown = not uptodown

            if uptodown:
                i = bisect.bisect_left(Z,zactual)
                g = G[i]
                c1 = C[i]
                c2 = C[i+1]
                mult = 1
            else:
                i = bisect.bisect_left(Z,zactual) -1
                g = G[i]
                c1 = C[i+1]
                c2 = C[i]
                mult = -1

            # Formule de Hovem 2013
            dx = np.abs((2 / (k * g)) * ( np.sqrt(1 - k**2 * c1**2 )) )
            dt = np.abs((2/g) * np.log( (1 + np.sqrt(1 - k**2 * c1**2))/(k * c1)  ) )
            # Fin du tratement du cas de reflexion

        else:
            # Cas normal
            dx = np.abs((1 / (k * g)) * (np.sqrt(1 - k**2 * c2**2 ) - np.sqrt(1 - k**2 * c1**2)))
            dt = np.abs((1/g) * np.log( (c2/c1) * ((1 + np.sqrt(1 - k**2 * c1**2)) /(1 + np.sqrt(1 - k**2 * c2**2))) ) )

        dz = mult * (Z[i+1] - Z[i])

        sumDt = np.sum(Dt)

        # Partie pour enregistrer des versions "arrondies"
        # (avec un dt régulier)
        #if tcut != 0:
            #while tcutlist.size != 0 and sumDt+dt >= tcutlist[0]:
                ##print 'into the while',sumDt
                #t =  tcutlist[0] - sumDt
                #c22 = 2*np.exp(t*g)*c1*(1+(-(k*c1-1)*(k*c1+1))**(1/2))/(k**2*np.exp(t*g)**2*c1**2+2+2*(-(k*c1-1)*(k*c1+1))**(1/2)-k**2*c1**2)
                #c2 = c22
                #dxr = np.abs((1 / (k * g)) * (np.sqrt(1 - k**2 * c2**2 ) - np.sqrt(1 - k**2 * c1**2)))
                #dtr = np.abs((1/g) * np.log( (c2/c1) * ((1 + np.sqrt(1 - k**2 * c1**2)) /(1 + np.sqrt(1 - k**2 * c2**2))) ) )
                #dzr = mult * (c2 - c1)/g

                #Dxround=np.append(Dxround,np.sum(Dx) + dxr)
                #Dtround=np.append(Dtround,np.sum(Dt) + dtr)
                #Dzround=np.append(Dzround,np.sum(Dz) + dzr)
                #tcutlist = tcutlist[1:]

        if sumDt + dt < tmax:
            # Enregistrement des Deltas si on est dessus de tmax
            Dx = np.append(Dx,dx)
            Dt = np.append(Dt,dt)
            Dz = np.append(Dz,dz)
        else:
            # Ajustement à la valeur tmax exacte
            if verbose:
                print(uptodown)
            t = tmax - sumDt
            c22 = 2*np.exp(t*g)*c1*(1+(-(k*c1-1)*(k*c1+1))**(1/2))/(k**2*np.exp(t*g)**2*c1**2+2+2*(-(k*c1-1)*(k*c1+1))**(1/2)-k**2*c1**2)

            c2 = c22
            dx = np.abs((1 / (k * g)) * (np.sqrt(1 - k**2 * c2**2 ) - np.sqrt(1 - k**2 * c1**2)))
            dt = np.abs((1/g) * np.log( (c2/c1) * ((1 + np.sqrt(1 - k**2 * c1**2)) /(1 + np.sqrt(1 - k**2 * c2**2))) ) )
            dz = mult * (c2 - c1)/g

            if verbose:
                print('fin',dx,dz,dt)

            Dx = np.append(Dx,dx)
            Dt = np.append(Dt,dt)
            Dz = np.append(Dz,dz)

        kriter = kriter +1

    toc = time.time()
    extime = toc-tic

    if verbose:
        print('nb iters : ' , kriter)
        print(("temps execution de SSP SnellDesc : %f" %(extime) ))

    return Dz, C, Dx, Dt, G, extime, (Dzround,Dxround,Dtround)

def raytrace_SD1_frontend( Zinp , Cinp , theta , zmax , cumsum = False ,
                          out_path_length = False , shift_90deg = False):
    """
    Délivre les informations de raytrace_SnellDesc1 directement utilisables
    i.e. des sommes cumulées
    voire les sommes finales si le flag cumsum est passé a False
    dans l'ordre X-Z (et pas Z-X comme pour la fonction initiale,
    sources d'erreurs bêtes)

    Input:
        theta : compté dans le sens trigo, l'origine est
                la verticale orientée vers le bas, en degré
                tir vers le nadir,  theta = 0
                tir vers l'horizon, theta = 85
                (dans le cas classique "up to down" il est donc > 0)
    Output:
        Dépend des options, mais dans cet ordre :
        X , Z , T , S

    """
    if shift_90deg:
        theta = 90 - theta

    Z, C, Dx, Dt, G, A, R, S, Ds , extime = \
    raytrace_SnellDesc(Zinp, Cinp, theta, zmax, mode='light')

    if       cumsum and out_path_length:
        return np.cumsum(Dx) , Z , np.cumsum(Dt) , np.cumsum(Ds)
    elif not cumsum and out_path_length:
        return np.sum(Dx) , Z[-1] , np.sum(Dt) , np.sum(Ds)
    elif     cumsum and not out_path_length:
        return np.cumsum(Dx) , Z , np.cumsum(Dt)
    elif not cumsum and not out_path_length:
        return np.sum(Dx) , Z[-1] , np.sum(Dt)

def raytrace_SD3_frontend(Zinp , Cinp , zstart , zmax , tmax , theta ,
                                tcut = 0.1 , plotflag = False , cumsum = False):
    """
    LA FONCTION 3 EST LENTE ET COMPLIQUÉE ...
    PRIVILEGIER LA SD1 ...

    Délivre les informations de raytrace_SnellDesc3 directement utilisables
    i.e. des sommes cumulées
    voire les sommes finales si le flag est passé a False
    dans l'ordre X-Z (et pas Z-X comme pour la fonction initiale,
    sources d'erreurs bêtes)

    Input:
        theta : compté dans le sens horaire
        (dans le cas classique "up to down" il est donc > 0)
        et en degré
        (contraire des autres fonctions, là aussi pour éviter les erreurs)
    """
    Dz, C, Dx, Dt, G, extime, Round = \
    raytrace_SnellDesc3(Zinp, Cinp , zstart , zmax , tmax , -theta, tcut)
    if plotflag:
        _,_ = plot_raytrace(Dz, Dx, Dt,Round)
    if cumsum:
        return np.cumsum(Dx) , np.cumsum(Dz) , np.cumsum(Dt)
    else:
        return np.sum(Dx) , np.sum(Dz) , np.sum(Dt)


#def find_dZ_for_fabrik_ping_OLD(Z,C,Angle_list,XYZ_bato,zpxp,procs=4,
#                            with_out_path_length=False,temporal_ZC=False):
#    """
#    Dz_lis : une cumsum
#    S_lis  : le path par couche
#    """
#    if not with_out_path_length:
#        print 'in find_dZ_for_fabrik_ping, not with_out_path_length mode'
#        args_lis = []
#        pool = mp.Pool(processes=procs)
#        if not temporal_ZC:
#            for a,zbato in zip(Angle_list,XYZ_bato):
#                args_lis.append((Z,C,a,zpxp,True))
#        else:
#            for Zt , Ct , a , zbato in zip(Z , C , Angle_list , XYZ_bato):
#                args_lis.append((Zt,Ct,a,zpxp,True))
#
#        results = [pool.apply(raytrace_SD1_frontend,args=x) for x in args_lis]
#        Dz_lis = [e[1] for e in results]
#        pool.close()
#        return Dz_lis
#    else:
#        print 'in find_dZ_for_fabrik_ping, with_out_path_length mode'
#        args_lis = []
#        pool = mp.Pool(processes=procs)
#        #for a,zbato in zip(Angle_list,XYZ_bato):
#        #   args_lis.append((Z,C,a,zpxp,True,True))
#
#        if not temporal_ZC:
#            for a,zbato in zip(Angle_list,XYZ_bato):
#                args_lis.append((Z,C,a,zpxp,True,True))
#        else:
#            for Zt , Ct , a , zbato in zip(Z , C , Angle_list , XYZ_bato):
#                args_lis.append((Zt,Ct,a,zpxp,True,True))
#
#        results = [pool.apply(raytrace_SD1_frontend,args=x) for x in args_lis]
#        Dz_lis  = [e[1] for e in results]
#        S_lis   = [np.diff(e[3]) for e in results]
#        pool.close()
#        return Dz_lis , S_lis

def find_dZ_for_fabrik_ping(Z,C,Angle_list,XYZ_bato,zpxp,procs=4,
                            with_out_path_length=False,temporal_ZC=False):
    """
    Dz_lis : une cumsum
    S_lis  : une cumsum DE même TAILLE que Dz_lis il y avait ambiguité avec la précdente fonction
    """
    if not with_out_path_length:
        #print 'in find_dZ_for_fabrik_ping, not with_out_path_length mode'
        args_lis = []
        pool = mp.Pool(processes=procs)
        if not temporal_ZC:
            for a,zbato in zip(Angle_list,XYZ_bato):
                args_lis.append((Z,C,a,zpxp,True))
        else:
            for Zt , Ct , a , zbato in zip(Z , C , Angle_list , XYZ_bato):
                args_lis.append((Zt,Ct,a,zpxp,True))

        results = [pool.apply(raytrace_SD1_frontend,args=x) for x in args_lis]
        Dz_lis = [e[1] for e in results]
        pool.close()
        return Dz_lis
    else:
        #print 'in find_dZ_for_fabrik_ping, with_out_path_length mode'
        args_lis = []
        pool = mp.Pool(processes=procs)
        #for a,zbato in zip(Angle_list,XYZ_bato):
        #   args_lis.append((Z,C,a,zpxp,True,True))

        if not temporal_ZC:
            for a,zbato in zip(Angle_list,XYZ_bato):
                args_lis.append((Z,C,a,zpxp,True,True))
        else:
            for Zt , Ct , a , zbato in zip(Z , C , Angle_list , XYZ_bato):
                args_lis.append((Zt,Ct,a,zpxp,True,True))

        results = [pool.apply(raytrace_SD1_frontend,args=x) for x in args_lis]
        Dz_lis  = [e[1] for e in results]
        S_lis   = [np.insert(e[3],0,0) for e in results]
        pool.close()
        return Dz_lis , S_lis


def multi_raytrace_SnellDesc(Zinp, Cinp , zstart , zmax , tmax , thetamin, thetamax, pas = 10):

    Dzout,Dxout,Dtout,roundout = [],[],[],[]

    thetatab = np.arange(thetamin,thetamax,pas)

    for theta in thetatab:
        Dz,_,Dx,Dt,_,_,roun = raytrace_SnellDesc3(Zinp, Cinp , zstart , zmax , tmax , theta)

        Dzout.append(Dz)
        Dxout.append(Dx)
        Dtout.append(Dt)
        roundout.append(roun)

    return Dzout,Dxout,Dtout,roundout

def plot_raytrace(Dz, Dx, Dt,Round):

    if genefun.is_listoflist(Dz):
        for ze,xe,te,re in zip(Dz,Dx,Dt,Round):

            z = np.cumsum(ze)
            x = np.cumsum(xe)
            t = np.cumsum(te)

            plt.plot(x,-z)#,color = np.cumsum(Dt))
            plt.plot(re[1],-re[0],'b*')
            plt.axis('equal')
    else:
        x = np.cumsum(Dx)
        z = np.cumsum(Dz)
        plt.plot(x,-z)#,color = np.cumsum(Dt))

    return x , -z


#def raytrace_seek(Xsrc, Xrec, Z, C, thetaminin=0, thetamaxin=88,
#                  verbose=True,fulloutput=True):
#    """RAYTRACE_SEEK Recherche le rayon acoustique qui relie le bateau et la
#     balise dans un SSP particulier, par la methode de la sécante, puis par dicotomie
#     ICI theta est INCONNU, si theta fixé : raytrace_SnellDesc
#     ENTREE :
#     Xsrc : La position du Bateau (vecteur 1x3 OU 3x1)
#     Xrec : La position du récepteur (vecteur 1x3 OU 3x1)
#     Z et C : le SSP
#     thetamin et thetamax : angles de "balayage" en degrés (IL N'EST PAS
#     RECOMMANDÉ UN THETAMAX > 88)
#     => ne sont utilisé que dans la 2nde partie, "dicotomie de la seconde chance"
#     SORTIE :
#     theta : angle d'emission du rayon acoustique
#     si fulloutput == True
#     Dx et Dt : distance horizontale et temps de parcours du rayon dans les
#     differentes couches du SSP
#     si fulloutput == False
#     X = cumsum(Dx) & T = cumsum(Dt)
#
#     Retourne:
#     Theta , x , t
#
#     Plus exactement :
#     if fulloutput:
#         return theta, Dx, Dt
#     else:
#        return theta , np.sum(Dx) , np.sum(Dt)
#    """
#
#    # assurons nous que l'on bosse avec des arrays
#    Z = np.array(Z)
#    C = np.array(C)
#
#    tic = time.time()
#
#    theta_geom = angle_geometrik(Xrec, Xsrc)
#    # empiriquement theta vrai ~ thetageo +ou- (+ !!!) 10 de thetageom
#    # delta = theta_geom * 0.1 # c'est absolument débile ce truc si on est proche de 0 !!! (150510)
#    delta = 15
#    thmin = theta_geom - delta
#    thmax = theta_geom + delta
#    # On maintient malgré tout les bornes en input comme les bornes opé
#    if thmin < thetaminin:
#        thmin = thetaminin
#    if thmax > thetamaxin:
#        thmax = thetamaxin
#    # Une clause pour les effets de bord
#    if thetaminin < 5:
#        thmin = thetaminin
#
#
#    if verbose:
#        print 'thmin & thmax operational :',thmin,thmax
#
#    nisec = 0
#    nidico = 0
#    kritersec , kriterdico = np.nan , np.nan
#
#    theta, Dx, Dt, nisec, kritersec = \
#    raytrace_seek_secante(Xsrc, Xrec, Z, C,thmin, thmax, 'secante', verbose=verbose) # nargout=3
#
#    snd_chance = False
#    if np.isnan(theta):
#        snd_chance = True
#
#    if snd_chance:
#        print 'seconde chance : recherche par dicotomie'
#        theta, Dx, Dt, nidico ,kriterdico = \
#        raytrace_seek_dicotomie(Xsrc, Xrec,Z,C,thetaminin,thetamaxin) # nargout=3
#
#    toc = time.time()
#    toctic = toc - tic
#    if verbose or snd_chance:
#        print ("Raytrace Seek : %f s, nb iter. sect./2coto.: %i/%i, stop : %f/%f " \
#        %(toctic,nisec,nidico,kritersec,kriterdico) )
#    if fulloutput:
#        return theta, Dx, Dt
#    else:
#        return theta , np.sum(Dx) , np.sum(Dt)


def raytrace_seek_mono(Xsrc, Xrec, Z, C, thetaminin=0, thetamaxin=88,
                  verbose=True,fulloutput=True,severe=False):
    """
    RAYTRACE_SEEK Recherche le rayon acoustique qui relie le bateau et la
    balise dans un SSP particulier, par la methode de la sécante, puis par dicotomie
    ICI theta est INCONNU, si theta fixé : raytrace_SnellDesc

    NB : raytrace_seek devient un wrapper pour le cas forward backward
    mais c'est raytrace_seek_mono qui est la vraie fct de recherche (151209 @ SIO)

     ENTREE :
         Xsrc : La position du Bateau (vecteur 1x3 OU 3x1)

         Xrec : La position du récepteur (vecteur 1x3 OU 3x1)

         Z et C:le SSP

         thetamin et thetamax : angles de "balayage" en degrés (IL N'EST PAS
         RECOMMANDÉ UN THETAMAX > 88)
         => ne sont utilisé que dans la 2nde partie, "dicotomie de la seconde chance"

     SORTIE :
         theta : angle d'emission du rayon acoustique
         si fulloutput == True
         Dx et Dt : distance horizontale et temps de parcours du rayon dans les
         differentes couches du SSP
         si fulloutput == False
         X = cumsum(Dx) & T = cumsum(Dt)

         Retourne:
             Theta , x , t

         Plus exactement :
             if fulloutput:
                 return theta, Dx, Dt
             else:
                return theta , np.sum(Dx) , np.sum(Dt)
    """


    # assurons nous que l'on bosse avec des arrays
    Z = np.array(Z)
    C = np.array(C)

    tic = time.time()

    theta_geom = angle_geometrik(Xrec, Xsrc)
    # empiriquement theta vrai ~ thetageo +ou- (+ !!!) 10 de thetageom
    # delta = theta_geom * 0.1 # c'est absolument débile ce truc si on est proche de 0 !!! (150510)
    delta = 15
    thmin = theta_geom - delta
    thmax = theta_geom + delta
    # On maintient malgré tout les bornes en input comme les bornes opé
    if thmin < thetaminin:
        thmin = thetaminin
    if thmax > thetamaxin:
        thmax = thetamaxin
    # Une clause pour les effets de bord
    if thetaminin < 5:
        thmin = thetaminin

    if verbose:
        print('thmin & thmax operational :',thmin,thmax)

    nisec  = 0
    nidico = 0
    kritersec , kriterdico = np.nan , np.nan

    theta, Dx, Dt, nisec, kritersec = \
    raytrace_seek_secante(Xsrc, Xrec, Z, C,thmin, thmax, 'secante', verbose=verbose) # nargout=3


    snd_chance = False
    if np.isnan(theta):
        snd_chance = True

    if snd_chance:
        print("ERR : raytrace_seek_mono : something failed ... theta, Dx, Dt are set as NaN")
        #print 'seconde chance : recherche par dicotomie'
        #theta, Dx, Dt, nidico ,kriterdico = \
        #raytrace_seek_dicotomie(Xsrc, Xrec,Z,C,thetaminin,thetamaxin) # nargout=3

    toc = time.time()
    toctic = toc - tic
    if verbose or snd_chance:
        print(("Raytrace Seek : %f s, nb iter. sect./2coto.: %i/%i, stop : %f/%f " \
        %(toctic,nisec,nidico,kritersec,kriterdico) ))

    if np.isnan(np.sum(Dx)):
        print("ERR : raytrace_seek_mono : NaN in sum(Dx)")
        print("      trick & tips : ")
        print("      * SSP (Z & C) vectors may be badly defined")
        print("        check them or use a Munk profile (using the option with_ssp_munk)")
        print("      * Some pings may be outliers or NaN")
        print("      * please clean or time-window the input data")

    if fulloutput:
        return theta, Dx, Dt
    else:
        return theta , np.sum(Dx) , np.sum(Dt)

def raytrace_seek(Xsrc_inp,Xrec, Z, C, thetaminin=0, thetamaxin=88,
                  verbose=True,fulloutput=True,severe=False):
    """
    RAYTRACE_SEEK Recherche le rayon acoustique qui relie le bateau et la
    balise dans un SSP particulier, par la methode de la sécante, puis par dicotomie
    ICI theta est INCONNU, si theta fixé : raytrace_SnellDesc


    NB : raytrace_seek devient un wrapper pour le cas forward backward
    mais c'est raytrace_seek_mono qui est la vraie fct de recherche (151209 @ SIO)

     ENTREE :
         Pour le cas forward/backward :
             Xsrc : tuple de la position du Bateau a l'emission & la réception,
             tuple(array(1,3) , array(1,3))
         Pour le cas standard :
             Xsrc : La position du Bateau, array (list non gerée) 1x3 OU 3x1

         Xrec : La position du récepteur, array (list non gerée) 1x3 OU 3x1

         Z et C:le SSP

         thetamin et thetamax : angles de "balayage" en degrés (IL N'EST PAS
         RECOMMANDÉ UN THETAMAX > 88)
         => ne sont utilisé que dans la 2nde partie, "dicotomie de la seconde chance"

     SORTIE :
         theta : angle d'emission du rayon acoustique
         si fulloutput == True
         Dx et Dt : distance horizontale et temps de parcours du rayon dans les
         differentes couches du SSP
         si fulloutput == False
         X = cumsum(Dx) & T = cumsum(Dt)

         Retourne:
             Theta , x , t

         Plus exactement :
             if fulloutput:
                 return theta, Dx, Dt
             else:
                return theta , np.sum(Dx) , np.sum(Dt)
    """
    if type(Xsrc_inp) is tuple and len(Xsrc_inp) == 2:
        #print 'INFO : mode forward/backward'
        theta1, Dx1, Dt1 = raytrace_seek_mono(Xsrc_inp[0], Xrec, Z, C, thetaminin=0, thetamaxin=88,
                  verbose=verbose,fulloutput=fulloutput,severe=severe)
        theta2, Dx2, Dt2 = raytrace_seek_mono(Xsrc_inp[1], Xrec, Z, C, thetaminin=0, thetamaxin=88,
                  verbose=verbose,fulloutput=fulloutput,severe=severe)
        try:
            return (theta1,theta2) , Dx1 + Dx2 , Dt1 + Dt2
        except:
            print("ERR : raytrace_seek : Dx1 & Dx2 have a different len. => Sum impossible")
            print("      return (theta1,theta2) , Dx1 , Dx2 , Dt1 , Dt2 , Xsrc_inp[0] , Xsrc_inp[1]")
            print("      for debug")
            print("trick : the ship's Up trajectory component may be bad, please check it")
            return (theta1,theta2) , Dx1 , Dx2 , Dt1 , Dt2 , Xsrc_inp[0] , Xsrc_inp[1]

    else:
        return raytrace_seek_mono(Xsrc_inp, Xrec, Z, C, thetaminin=0, thetamaxin=88,
                  verbose=verbose,fulloutput=fulloutput,severe=severe)

def raytrace_seek_bilin_input(Xsrc, Xrec, g1, g2, cs, zb,
                              thtmin=0, thtmax=88,
                              verbose=True,fulloutput=True):

    Z,C = acls.bilin_grads_2_SSP(g1,g2,cs,zb)

    out = raytrace_seek(Xsrc, Xrec, Z, C, thetaminin=thtmin,
                  thetamaxin=thtmax,verbose=verbose,
                  fulloutput=fulloutput)
    return out


# Autogenerated with SMOP version 0.23
# main.py /home/psakic01/THESE/CodeMk4/fonctions/raytrace/raytrace_seek_secante.m

def raytrace_seek_secante(Xsrc, Xrec, Z, C, thetamin, thetamax, mode,
                          verbose=True,
                          z_src_as_ref=False):
    """RAYTRACE_SEEK Recherche le rayon acoustique qui relie le bateau et la
     balise dans un SSP particulier, par la methode de Newton-Raphson
     ou plus exactement la methode de la sécante dans le cas discret
     ICI theta est INCONNU, si theta fixé : raytrace_SnellDesc
     ENTREE :
     Xsrc : La position du Bateau (vecteur 1x3 OU 3x1)
     Xrec : La position du récepteur (vecteur 1x3 OU 3x1)
     Z et C : le SSP
     thetamin et thetamax : angles de "balayage" en degrés
     mode : 'secante' ou 'fausse_prop'
     z_src_as_ref : use the source heigth / depth (Xsrc[2]) as ref
                     use a 0 depth instead
                     True is highly recommended ! False is only for debug
     SORTIE :
     theta : angle d'emission du rayon acoustique
     Dx et Dt : distance horizontale et temps de parcours du rayon dans les
     differentes couches du SSP

     On cherche x(theta) - x_vrai = 0
     on pose X(theta) = x(theta) - x_vrai.
     ou x_vrai est la distance horizontale vraie
     FIN DE L'EN TETE
    """

    if not  mode == 'secante' and not  mode == 'fausse_prop':
        error('ERREUR : verifier la variable mode')

    x_vrai  = np.linalg.norm(Xrec[0:2] - Xsrc[0:2])

    i = 1
    imax = 100
    # Condition sur le nombre d'iteration max pour gerer les effets de bords
    thetageom = angle_geometrik(Xsrc, Xrec)
    if thetageom > 84 and thetamax > 84:
        imax = 300
    if thetageom < 5 and thetamax < 5:
        imax = 300
    xstop = 10 ** 9
    kriter = 10 ** 9
    kriterstop = (10 ** - 7)/4 #critere d'arret des recherches
    if thetamin < 2 or thetamax < 2: # gestion de l'aplomb, il faut être plus lâche sur le critère
        imax = 500
        kriterstop = (10 ** - 6)

    a = thetamax
    b = thetamin

    #  a = np.max((thetamin,thetamax))
    #  b = np.min((thetamin,thetamax))


    if z_src_as_ref:
        z_src_rec = abs(Xrec[2] - Xsrc[2])
    else:
        if verbose:
            print("WARN : raytrace_seek_secante : z_src_as_ref = False !")
        z_src_rec = abs(Xrec[2] - 0.)


    while kriter > kriterstop and i < imax:
        if verbose:
            print('th a & b' , a , b)

        _,_,Dxa,_,_,_,_,_,_,_ = raytrace_SnellDesc(Z, C, a, z_src_rec) # nargout=8
        _,_,Dxb,_,_,_,_,_,_,_ = raytrace_SnellDesc(Z, C, b, z_src_rec) # nargout=8


        #raytrace_ultimate(xo,abs(Xrec[2] - Xsrc[2]), a,tt,Z,C)
        #raytrace_ultimate(xo,abs(Xrec[2] - Xsrc[2]), b,tt,Z,C)


        xa = np.sum(Dxa)
        xb = np.sum(Dxb)
        fb = xb - x_vrai
        fa = xa - x_vrai
        c = a - np.dot(((a - b) / (fa - fb)), fa)


        if mode == 'fausse_prop':
            _,_,Dxc,_,_,_,_,_,_,_= raytrace_SnellDesc(Z, C, c, z_src_rec) # nargout=8
            xc = np.sum(Dxc)
            xstop = xc
            x_vrai - xc
            fc = xc - x_vrai
            if np.dot(fa*fc) > 0:
                a = c
            else:
                b = c
        else:
            if mode == 'secante':
                b = a
                a = c
                xstop = xa
        i = i + 1
        kriter = abs(x_vrai - xstop)

    theta = c
    #======== tracé pour debug ========
    #j=1;
    #for aa=thetamin:1:thetamax
    #[Z,C,Dx,Dt,G,A,R] = raytrace_SnellDesc( Z , C , aa , abs(Xrec(3)));
    #stkX(j)=sum(Dx);
    #stkA(j)=aa;
    #j=j+1;
    #end
    #plot(stkA,stkX-x_vrai);
    #==================================
    if i >= (imax - 3):
#        warnings.warn('ATTENTION : nombre iteration proche de' + str(imax))
        print('ATTENTION : nombre iteration proche de' + str(imax) + ' (sect.)')
        print('pour info, x - sum(Dx), theta : ')
        print((x_vrai - xstop))
        print (theta)
        theta = np.nan
        Dx = np.nan
        Dt = np.nan
    if not np.isreal(xstop):
#        warnings.warn('ATTENTION : xstop est un complexe')
        print('ATTENTION : xstop est un complexe (sect.)')
        theta = np.nan
        Dx = np.nan
        Dt = np.nan

    if i < (imax - 3) and np.isreal(xstop):
        _,_,Dx,Dt,_,_,_,_,_,_ = raytrace_SnellDesc(Z, C, theta, z_src_rec) # nargout=8

    return theta, Dx, Dt, i , kriter

# Autogenerated with SMOP version 0.23
# main.py /home/psakic01/THESE/CodeMk4/fonctions/raytrace/raytrace_seek_dicotomie.m

def raytrace_seek_dicotomie(Xsrc, Xrec, Z, C, thetamin, thetamax):
    """RAYTRACE_SEEK Recherche le rayon acoustique qui relie le bateau et la
     balise dans un SSP particulier
     ICI theta est INCONNU, si theta fixé : raytrace_SnellDesc
     ENTREE :
     Xsrc : La position du Bateau (vecteur 1x3)
     Xrec : La position du récepteur (vecteur 1x3)
     Z et C : le SSP
     thetamin et thetamax : angles de "balayage" en degrés
     SORTIE :
     theta : angle d'emission du rayon acoustique
     Dx et Dt : distance horizontale et temps de parcours du rayon dans les
     differentes couches du SSP

     Recherche par Dichotomie :
     inf                    mil                   sup
     || ------------------ |x| ------------------ ||

     FIN DE L'EN TETE
    """
    inf = thetamin
    sup = thetamax
    #x : distance horizontale VRAIE
    x = np.linalg.norm(Xrec[0:2] - Xsrc[0:2])
    #x : distance horizontale calculée qui doit etre la + proche de x
    xvar = 10**9
    kriter = 10**9
    i = 0
    kriterstop = (10 ** -7)/4 #critere d'arret des recherches

    # ======== tracé pour debug ========
    # for aa=inf:1:sup
    #     [Z,C,Dx,Dt,G,A,R] = raytrace_SnellDesc( Z , C , aa , abs(Xrec(3)));
    #     stkX(j)=sum(Dx);
    #     stkA(j)=aa;
    #     j=j+1;
    #
    # end
    # plot(stkA,stkX-x);
    # ==================================
    while kriter > kriterstop and i < 100:

        mil = (sup + inf) / 2
        # mil
        # sup
        # inf
        _,_,Dxmil,_,_,_,_,_,_,_ = raytrace_SnellDesc(Z, C, mil, abs(Xrec[2] - Xsrc[2]))
        _,_,Dxinf,_,_,_,_,_,_,_ = raytrace_SnellDesc(Z, C, inf, abs(Xrec[2] - Xsrc[2]))
        _,_,Dxsup,_,_,_,_,_,_,_ = raytrace_SnellDesc(Z, C, sup, abs(Xrec[2] - Xsrc[2]))

        xmil = np.sum(Dxmil)
        xinf = np.sum(Dxinf)
        xsup = np.sum(Dxsup)
        #abs(x - xinf)
        #abs(x - xsup)
        if ((x - xinf)*(x - xmil)) < 0:
            #'le 0 se trouve dans la partie "inf" '
            theta = inf
            sup = mil
            xvar = xinf
        else:
            #'le 0 se trouve dans la partie "sup" '
            theta = sup
            inf = mil
            xvar = xsup
        i = i + 1
        kriter = np.abs(x - xvar)

    if i >= 97:
        #warnings.warn('ATTENTION : nombre iteration proche de 100')
        print('ATTENTION : nombre iteration proche de 100 (dico.)')
        print('pour info, x - sum(Dx), theta : ')
        print(x - xvar)
        print(theta)
        theta = np.nan
        Dx = np.nan
        Dt = np.nan
    if not  np.isreal(x - xvar):
        #warning('ATTENTION : x - xvar est un complexe')
        print('ATTENTION : x - xvar est un complexe (dico.)')
        theta = np.nan
        Dx = np.nan
        Dt = np.nan

    if i < 97 and np.isreal(x - xvar):
        _,_,Dx,Dt,_,_,_,_,_,_  = raytrace_SnellDesc(Z, C, theta, abs(Xrec[2] - Xsrc[2])) # nargout=8

    return theta, Dx, Dt, i , kriter


#def time_spend_in_layer_zones_OLD(zones_bound,Dz_in,Dt_in,severe=True):
#    """
#    Input :
#        zones bound : a list of bounds 0 and 99999 (max depth) are added if not
#
#        Dz : the CUMULATIVE depth of a ping
#
#        Dt : the time spend in each layer (not cumulative),
#        can also be the path length
#    Return :
#        t_zones_sum : the time spend in each zone
#        propor_lis  : the proportion
#    """
#
#    sumT = np.sum(Dt_in)
#
#    t_zones_lis_lis = []
#    for i in range(len(zones_bound)-1):
#        t_zones_lis_lis.append([])
#        for dz,dt in zip(Dz_in,Dt_in):
#            if zones_bound[i] <= dz <  zones_bound[i+1]:
#                t_zones_lis_lis[i].append(dt)
#
#    t_zones_sum = []
#    for tzl in t_zones_lis_lis:
#        sumtzl = np.sum(tzl)
#        if sumtzl != 0:
#            t_zones_sum.append( sumtzl )
#
#    try:
#        propor_lis = list(np.array(t_zones_sum) / sumT)
#    except Exception as exep:
#        print exep
#        print "ERR : time_spend_in_layer_zones : list(np.array(t_zones_sum) / sumT)"
#        print np.array(t_zones_sum) , sumT , Dt_in
#
#    if np.abs(np.sum(t_zones_sum) - sumT) > 10**-9:
#        print "WARN : np.sum(t_zones_sum) != np.sum(Dt_in) !!!"
#        print "np.abs(np.sum(t_zones_sum) - sumT) = "
#        print np.abs(np.sum(t_zones_sum) - sumT)
#        if severe:
#            print "severe mode : return t_zones_sum , sumT"
#            return t_zones_sum , sumT
#
#    return np.array(t_zones_sum) , np.array(propor_lis)


def time_spend_in_layer_zones(zones_bound,Dz_in,Dt_or_Ds_in,severe=False,
                              Dt_or_Ds_mode='Dt'):
    """
    Input :
        zones bound : a list of bounds 0 and 99999 (max depth)

        Dz : the CUMULATIVE depth of a ping

        Dt : the CUMULATIVE time spend in each layer,
        can also be the path length

        len(Dz) == len(Dz) in this function

    Return :
        t_zones_sum : the time spend in each zone
        propor_lis  : the proportion
    """

    if Dt_or_Ds_mode == 'Dt':
        Dt_in = Dt_or_Ds_in
        sumT  = np.sum(Dt_in)
        I = scipy.interpolate.interp1d( Dz_in , np.cumsum(Dt_in)   ,
                                       fill_value=np.nan,
                                       bounds_error=False)
        Tinterp = I(np.array(zones_bound[1:]))
        indnan = np.squeeze(np.argwhere(np.isnan(Tinterp)))
        Tinterp[indnan]  = sumT
        t_zones_sum = np.diff(np.insert(Tinterp,0,0))

        abs_sum = t_zones_sum
        summ    = sumT

    elif Dt_or_Ds_mode == 'Ds':
        Ds_in = Dt_or_Ds_in
        sumS  = np.sum(Ds_in)
        I = scipy.interpolate.interp1d( Dz_in , Ds_in   ,
                                       fill_value=np.nan,
                                       bounds_error=False)
        Sinterp = I(np.array(zones_bound[1:]))
        indnan = np.squeeze(np.argwhere(np.isnan(Sinterp)))
        Sinterp[indnan] = sumS
        s_zones_sum = np.diff(np.insert(Sinterp,0,0))

        abs_sum = s_zones_sum
        summ    = sumS

    propor_lis = np.array(abs_sum) / summ

    if np.abs(np.sum(abs_sum) - summ) > 10**-8:
        print("WARN : np.sum(t_zones_sum) != np.sum(Dt_in) !!!")
        print("np.abs(np.sum(t_zones_sum) - sumT) = ")
        print(np.abs(np.sum(abs_sum) - summ))
        if severe:
            print("severe mode : return t_zones_sum , sumT")
            return abs_sum , summ

    return np.array(abs_sum) , np.array(propor_lis)



def noise_in_zones(zones_bound,sigma_zones,Dz_list,Dt_Ds_list,abs_mode=True):
    """
    Can manage a Dz_list => it makes a list/Singleton
    Input :
        mode : "absolute" or "propor"
               if abs_mode is False, then propor
               absolute is strongly recommanded

    Dt_Ds_list est soit la liste des Dt, soit la liste des Ds
    SOIT un tuple (Dt,Ds)
    """

    if not genefun.is_listoflist(Dz_list):
        Dz_list    = [Dz_list]
    if not genefun.is_listoflist(Dt_Ds_list):
        Dt_Ds_list = [Dt_Ds_list]

    zones_bound = list(zones_bound)

    if zones_bound[0]  != 0:
        zones_bound.insert(0,0)
    if zones_bound[-1] != 99999:
        zones_bound.append(99999)
    if sigma_zones.shape[1] != len(zones_bound) - 1 :
        print("WARN : bound/sigma len errors")

    #print 'INFO : len(zones_bound)' ,len(zones_bound)

    out_noises_lis = []
    if type(Dt_Ds_list) is tuple:
        # cette boucle est pour chaque ping
        for iii,(Dz , Dt , Ds , sigs) in enumerate(zip(Dz_list,Dt_Ds_list[0],Dt_Ds_list[1],sigma_zones)):

            t_zones_sum , propor_lis = time_spend_in_layer_zones(zones_bound,
                                                                 Dz,Dt,Dt_or_Ds_mode='Dt')
            s_zones_sum , propor_lis = time_spend_in_layer_zones(zones_bound,
                                                                 Dz,Ds,Dt_or_Ds_mode='Ds')

            t_zones_sum = np.array(t_zones_sum)
            s_zones_sum = np.array(s_zones_sum)



            def divide_improved(A,B,if_error = 0. ):
                outlis = []

                for a,b in zip(A,B):
                    try:
                        out = float(a) / float(b)
                    except:
                        out = if_error
                    outlis.append(out)
                return np.array(outlis)


            try:
                c_zones_sum = divide_improved(s_zones_sum,t_zones_sum)

            except Exception as e:
                print("PANIC : vect size in noise_in_zone, \
                maybe something went wrong in the bound adding")
                print(s_zones_sum.shape , t_zones_sum.shape)
                print(s_zones_sum       , t_zones_sum)

                raise e

            if abs_mode:
                c_zones_mod = sigs[:len(c_zones_sum)] + c_zones_sum
                t_zones_mod = divide_improved(s_zones_sum , c_zones_mod)

                out_noises_lis.append(t_zones_sum - t_zones_mod)
            else:
                print("WARN : this non abs_mod is discontinued ...")
                out_noises_lis.append(np.multiply(propor_lis ,(sigs + c_zones_sum)**(-1)))
    else:
        "WARN : this mode is discontinued"
        for iii,(Dz , Dts , sigs) in enumerate(zip(Dz_list,Dt_Ds_list,sigma_zones)):
            t_s_zones_sum , propor_lis = time_spend_in_layer_zones(zones_bound,Dz,Dts)

            if abs_mode:
                out_noises_lis.append(np.multiply(t_s_zones_sum,sigs))
            else:
                out_noises_lis.append(np.multiply(propor_lis,sigs))

        #return genefun.array_from_lists(out_noises_lis)
    return np.column_stack(out_noises_lis)

# Autogenerated with SMOP version 0.23
# main.py /home/psakic01/THESE/CodeMk4/fonctions/raytrace/angle_geometrik.m

def angle_geometrik(Xrec, Xsrc):
    hypo = np.linalg.norm(Xsrc - Xrec)
    prof = Xrec[2] - Xsrc[2]
    theta = np.rad2deg(np.arccos(prof / hypo))
    return theta

# -*- coding: utf-8 -*-
# Autogenerated with SMOP version 0.23
# main.py /home/psakic01/THESE/CodeMk4/fonctions/raytrace/raytrace_diff.m

#def raytrace_diff(Xsrc, Xrec, Z, C, h=0, diffmode = 'centre', diffwhat = 'all'):
#    """differencie numeriquement la fonction de ray tracing d'un pas h
#     diffmode =  'prog' , 'retro' ou 'centre' : dérivation "en avant" (+h),
#     "en arrière" (-h)  ou "centrée( / 2h) "
#
#     diffwhat = 'all' , 'onlysrc' , 'onlyrec'
#
#     DISCONTINUED FCT, THE LIGHT ONE SHALL BE PREFERED
#    """
#    dXsrc = np.empty(shape=(3), dtype='float64')
#    dXrec = np.empty(shape=(3), dtype='float64')
#
#    __, __, Dttrue = raytrace_seek(Xsrc, Xrec, Z, C, 1, 89,verbose=False) # nargout=3
#    Ttrue = np.sum(Dttrue)
#
#    if diffwhat != 'all' and diffwhat != 'onlysrc' and diffwhat != 'onlyrec' :
#        raise Exception("verifier argument diffwhat")
#
#    if diffmode == 'centre':
#            # Diference centrée
#            # Pour les coordonnées du bateau (gaffe au 'not' qui change tout)
#            if not  diffwhat == 'onlyrec':
#                print diffwhat , 'aaa'
#                for xyz in range(3):
#                    matbool = np.array([0, 0, 0])
#                    matbool[xyz] = 1
#                    Xsrc_h = Xsrc + matbool * h
#                    __, __, Dt1 = raytrace_seek(Xsrc_h, Xrec, Z, C, 1, 89,verbose=False) # nargout=3
#                    Xsrc_h = Xsrc - matbool * h
#                    __, __, Dt2 = raytrace_seek(Xsrc_h, Xrec, Z, C, 1, 89,verbose=False) # nargout=3
#                    dXsrc[xyz] = (np.sum(Dt1) - np.sum(Dt2)) / (2*h)
#                    Dt1 = np.array([])
#                    Dt2 = np.array([])
#            # Pour les coordonnées de la balise fond (gaffe au 'not' qui change tout)
#            if not  diffwhat == 'onlysrc':
#                print diffwhat , 'bbb'
#                for xyz in range(3):
#                    matbool = np.array([0, 0, 0])
#                    matbool[xyz] = 1
#                    Xrec_h = Xrec + matbool * h
#                    __, __, Dt1 = raytrace_seek(Xsrc, Xrec_h, Z, C, 1, 89,verbose=False) # nargout=3
#                    Xrec_h = Xrec - matbool * h
#                    __, __, Dt2 = raytrace_seek(Xsrc, Xrec_h, Z, C, 1, 89,verbose=False) # nargout=3
#                    dXrec[xyz] = (np.sum(Dt1) - np.sum(Dt2)) / (2*h)
#                    Dt1 = np.array([])
#                    Dt2 = np.array([])
#
#    elif diffmode == 'prog' or diffmode == 'retro' :
#
#        if diffmode == 'prog' :
#            ploumo = 1 # ploumo = plus ou moins
#        elif diffmode == 'retro' :
#            ploumo = -1
#        else:
#            raise Exception("verifier argument diffmode")
#
#        # Difference en avant
#        # Pour les coordonnées du bateau (gaffe au 'not' qui change tout)
#        if not  diffwhat == 'onlyrec':
#            for xyz in range(3):
#                matbool = np.array([0, 0, 0])
#                matbool[xyz] = 1
#                Xsrc_h = Xsrc + ploumo * matbool * h
#                __, __, Dt = raytrace_seek(Xsrc_h, Xrec, Z, C, 1, 89,verbose=False) # nargout=3
#                dXsrc[xyz] = (ploumo * np.sum(Dt) - ploumo * Ttrue) / h
#                Dt = np.array([])
#        # Pour les coordonnées de la balise fond (gaffe au 'not' qui change tout)
#        if not  diffwhat == 'onlysrc':
#            for xyz in range(3):
#                matbool = np.array([0, 0, 0])
#                matbool[xyz] = 1
#                Xrec_h = Xrec + ploumo * matbool * h
#                __, __, Dt = raytrace_seek(Xsrc, Xrec_h, Z, C, 1, 89,verbose=False) # nargout=3
#                dXrec[xyz] = (ploumo * np.sum(Dt) - ploumo * Ttrue) / h
#                Dt = np.array([])
#    else:
#        raise Exception("verifier argument diffmode")
#
#    return dXsrc, dXrec
#
#
#def raytrace_diff_light_old1(Xsrc, Xrec, Z, C, h=0):
#    """version classique avec derviation avant arrière"""
#    dX = np.empty(shape=(3), dtype='float64')
#
#    Xsrc = np.array(Xsrc)
#    Xrec = np.array(Xrec)
#
#    if h == 0:
#        epsil_h = True
#        h_xyz = Xrec * np.sqrt(np.finfo(float).eps)
#    else:
#        epsil_h = False
#
#    for xyz in range(3):
#        matbool = np.array([0, 0, 0])
#        matbool[xyz] = 1
#        if epsil_h:
#            h = h_xyz[xyz]
#        Xrec_h = Xrec + matbool * h
#        __, __, Dt_plus = raytrace_seek(Xsrc, Xrec_h, Z, C, 1, 89,verbose=False)
#        Xrec_h = Xrec - matbool * h
#        __, __, Dt_moins = raytrace_seek(Xsrc, Xrec_h, Z, C, 1, 89,verbose=False)
#        dX[xyz] = (np.sum(Dt_plus) - np.sum(Dt_moins)) / (2*h)
#    return dX


def get_accur_coeff(i):
    accur_coeff_mat = np.array([[0,0,0,-1/2.,0,1/2.,0,0,0],
    [0,0,1/12. ,-2/3.,0,2/3.,-1/12.,0,0],
    [0,-1/60.,3/20.,-3/4.,0,3/4.,-3/20.,1/60.,0],
    [1/280.,-4/105.,1/5.,-4/5.,0,4/5.,-1/5.,4/105.,-1/280.]])
    if i > 3:
        return accur_coeff_mat[-1]
    else:
        return accur_coeff_mat[i]


#def raytrace_diff_light_old2(Xsrc, Xrec, Z, C, h=0 , accur = 0):
#    """ Version avec une imporved derivation """
#    dX = np.empty(shape=(3), dtype='float64')
#
#    Xsrc = np.array(Xsrc)
#    Xrec = np.array(Xrec)
#
#    if h == 0:
#        epsil_h = True
#        h_xyz = Xrec * np.sqrt(np.finfo(float).eps)
#    else:
#        epsil_h = False
#
#    accur_coeff = get_accur_coeff(accur)
#
#    for xyz in range(3):
#        matbool = np.array([0, 0, 0])
#        matbool[xyz] = 1
#        if epsil_h:
#            h = h_xyz[xyz]
#        T_stk = []
#        for i,k in enumerate(accur_coeff):
#            if k == 0:
#                T_stk.append(0.)
#            else:
#                Xrec_h = Xrec + matbool  * h * (i-4)
#                __ , __ , Dt = raytrace_seek(Xsrc, Xrec_h, Z, C, 1, 89,verbose=False)
#                T = np.sum(Dt)
#                T_stk.append(T)
#        dX[xyz] = np.dot(np.array(T_stk) , accur_coeff) / h
#    return dX


def raytrace_diff_light(Xsrc, Xrec, Z, C, h=0 , accur = 0 , Xrefbary = []):
    """ Au final l'implémentation du barycentre sous forme X+dX est
    inutile parce que c'est une somme ...
    Mais on le laisse quand même

    Retro compatible avec old 1 et old 2

    EDIT 151209 (@SIO) : rendu compatible pour une 2ble position de la source
                         sous forme de 2-tuple
    """

    dX = np.empty(shape=(3), dtype='float64')

    if type(Xsrc) is tuple and  len(Xsrc) == 2:
        Xsrc = (np.array(Xsrc[0]),np.array(Xsrc[1]))
    else:
        Xsrc = np.array(Xsrc)

    Xrec = np.array(Xrec)

    if Xrefbary != []:
        Xrefbary = np.array(Xrefbary)

    if h == 0:
        epsil_h = True
        if Xrefbary == []:
            h_xyz = Xrec * np.sqrt(np.finfo(float).eps)
            h_xyz_lis = [h_xyz]
        else:
            h_xyz_dXrec = Xrec * np.sqrt(np.finfo(float).eps)
            h_xyz_Xbary = Xrefbary * np.sqrt(np.finfo(float).eps)
            h_xyz_lis = [h_xyz_dXrec,h_xyz_Xbary]

    else:
        epsil_h = False

    accur_coeff = get_accur_coeff(accur)

    dX_stk = []
    for iii , h_xyz in enumerate(h_xyz_lis):
        for xyz in range(3):
            matbool = np.array([0, 0, 0])
            matbool[xyz] = 1
            if epsil_h:
                h = h_xyz[xyz]
            T_stk = []
            for i,k in enumerate(accur_coeff):
                if k == 0:
                    T_stk.append(0.)
                else:
                    if Xrefbary == []:
                        Xrec_h = Xrec + matbool  * h * (i-4)
                    else:
                        Xrec_h = Xrec + Xrefbary + matbool  * h * (i-4)
                    __ , __ , Dt = raytrace_seek(Xsrc, Xrec_h, Z, C, 1, 89,verbose=False)
                    T = np.sum(Dt)
                    T_stk.append(T)
            dX[xyz] = np.dot(np.array(T_stk) , accur_coeff) / h
        dX_stk.append(dX)

    if len(dX_stk) == 1:
        return dX_stk[0]
    else:
        return dX_stk



def raytrace_diff2_wrapper(xsrc,ysrc,zsrc,xrec,yrec,zec,Z,C):
    Xsrc = np.array([xsrc,ysrc,zsrc])
    Xrec = np.array([xrec,yrec,zec])
    __, __, Dt = raytrace_seek(Xsrc,Xrec,Z,C,1,89,False)
    return np.sum(Dt)

def raytrace_diff2(Xsrc,Xrec,Z,C,h=1e-6):
    # Front end using the function devrivative of scipy
    # DISCONTINUED
    arguments = [Xsrc[0],Xsrc[1],Xsrc[2],Xrec[0],Xrec[1],Xrec[2],Z,C]
    out = []
    for i in range(6):
        out.append(partial_derivative(raytrace_diff2_wrapper,i,arguments,dx=h))
    return out

def rt_SD_wrap_rootfind(theta_and_t,Xrec,zsrc,Zinp , Cinp):
    """
    Shall be used like this exemple :
    outtup = scipy.optimize.root(rt_SD_wrap_rootfind , theta_and_t , args=(Xrec,zsrc,Z,C),tol=10**-1,method='hybr')
    """

    theta,t = theta_and_t
    r0 = np.sqrt(Xrec[0]**2 + Xrec[1]**2)
    z0 = Xrec[2]
    r1,z1,t1 = rt.raytrace_SnellDesc_frontend(Zinp, Cinp , zsrc , z0 , t, \
                                           theta,tcut = 0.1,plotflag = False, \
                                           cumsum = False)

    return np.array([r0,z0]) - np.array([r1,z1])


def circle_center(x1,y1,x2,y2,R):
    """
    Give the 2 circles of radius R which cross the 2 points
    """
    x3 = (x1+x2)/2
    y3 = (y1+y2)/2

    q = np.sqrt((x2-x1)**2 + (y2-y1)**2)

    xc1 = x3 + np.sqrt(r**2-(q/2)**2)*(y1-y2)/q
    yc1 = y3 + np.sqrt(r**2-(q/2)**2)*(x2-x1)/q

    xc2 = x3 - np.sqrt(r**2-(q/2)**2)*(y1-y2)/q
    yc2 = y3 - np.sqrt(r**2-(q/2)**2)*(x2-x1)/q

    return xc1,yc1,xc2,yc2

def raytrace_SnellDescRK(Zinp, Cinp , zstart , zmax , tmax , theta, tcut = 0.1):
    """La première profondeur ( Z(1) ) doit être zero (la surface)
     (extrapolation sinon a prévoir)

     amélioration de la vers 2
     avec temps t exacts sous forme de points

     ICI theta est FIXE, si recherche de theta : raytrace_seek

     Basé sur Chadwell 2010 , p 175
     ENTREE :
     Zinp, Cinp : Sound Speend Profile (inp pour input)
     theta : angle d'incidence suivant la surface, compté dans le sens horaire, en degrés

     zmax : la profondeur maxi ou on effectue le Ray tracing
            Si = 0, ray tracing pout tout la colonne Z
     mode : 'light' ou 'full' : light (par def) ne calcule que Dx et Dt
     SORTIE :
     Z : Profondeur [ 0 ,zmax ] (frontière de couche, taille N)
     C : Vitesse [ 0 ,zmax ] (frontière de couche, taille N)
     Dx : Déplacement en plani (couche, 0 + taille N-1)
     Dt : Temps de propagation par couche (couche, taille 0 + N-1)
     G : gradient dans chaque couche (couche, taille N-1)

     NB : Dx Dt et R S : premier elt = 0 (pour coincider avec les autres vecteurs)
     0) test si zmax > max(Z)
    """
    tic = time.time()

    if zmax > np.max(Zinp):
        warnings.warn('ATTENTION : zmax > max(Z) => extrapolation de C')
        Z, C = SSP_extrapolate(Zinp, Cinp, zmax, 100) # nargout=2
    else:
        Z = Zinp.copy()
        C = Cinp.copy()
    # 00) fabrication de Z avec zmax pour element maxi, et d'un C interpolé
    # correspondant
    if zmax != np.max(Z) and zmax != 0:
        # warnings.warn("ATTENTION : zmax != max(Z) => decoupage de Z et C \
        #\n pensez à le faire en amont ")
        Z, C = SSP_cut(Z, C, zmax) # nargout=2
    # recherche du gradient b de chaque couche => interpolation linéaire
    n = len(Z)
    m = len(Z) - 1

    dC = np.diff(C)
    dZ = np.diff(Z)

    G = dC / dZ

    # définition de k = cos(theta)/c => Invariant de Snell Descartes
    theta = np.deg2rad(theta)
    k = np.cos( theta) /C[ bisect.bisect_left(Z,zstart) ]

    # Définition de la direction du rayon
    if theta >= 0 :
        uptodown = True
    else:
        uptodown = False

    kriter = 0

    r = []
    z = []
    eta = []
    zeta = []

    r.append(0)
    z.append(zstart)

    eta.append( np.cos(theta) /C[ bisect.bisect_left(Z,zstart) ] )
    zeta.append( np.sin(theta) /C[ bisect.bisect_left(Z,zstart) ] )

    h = 0

    while h < 100:

        i = bisect.bisect_left(Z,z[-1])
        g = G[i]
        c = G[i]

        kr1 = c * eta[-1]
        kz1 = c * zeta[-1]
        keta1  = -(1/c**2) * 0
        kzeta1 = -(1/c**2) * g

        kr2 = c * (eta[-1] + 0.5*h*keta1 )
        kz2 = c * (zeta[-1] + 0.5*h*kzeta1 )
        keta2  = -(1/c**2) * 0
        kzeta2 = -(1/c**2) * g

        kr3 = c * (eta[-1] + 0.5*h*keta2 )
        kz3 = c * (zeta[-1] + 0.5*h*kzeta2 )
        keta3  = -(1/c**2) * 0
        kzeta3 = -(1/c**2) * g

        kr4 = c * (eta[-1] + h*keta3 )
        kz4 = c * (zeta[-1] + h*kzeta3 )
        keta4  = -(1/c**2) * 0
        kzeta4 = -(1/c**2) * g

        rnew = r[-1] + (h/6) * (kr1 + 2*kr2 + 2*kr3 + kr4)
        znew = z[-1] + (h/6) * (kz1 + 2*kz2 + 2*kz3 + kz4)
        etanew = eta[-1] + (h/6) * (keta1 + 2*keta2 + 2*keta3 + keta4)
        zetanew = zeta[-1] + (h/6) * (kzeta1 + 2*kzeta2 + 2*kzeta3 + kzeta4)

        r.append(rnew)
        z.append(znew)
        eta.append(etanew)
        zeta.append(zetanew)

        h = h + 1
        print(h)

    return r,z,eta,zeta

def munk_fct(z,epsilon = 0.00737,z_c = 1300):
    epsilon = float(epsilon)
    z_c = float(z_c)
    z_til = 2. * ((z - z_c)/(z_c))
    return 1500. * (1. + epsilon * (z_til - 1. + np.exp(-z_til)))

def exp_dble_fct(x,a,b,c,d):
    return a*np.exp(b*x) + c*np.exp(d*x)

def apri_for_exp_dble():
    return (87.9,-0.002533,1467,9.991e-06)

def fit_dbl_exp_SSP(Z,C,dz=1,zup=None,zdown=None):
    coef_dbl_exp , _ = curve_fit(exp_dble_fct,Z,C,apri_for_exp_dble())
    if zup is None:
        zup = np.min(Z)
    if zdown is None:
        zdown = np.max(Z)
    Zfit = np.arange(zup,zdown+1,dz)
    Cfit = exp_dble_fct(Zfit,*coef_dbl_exp)
    return Zfit , Cfit


#  ______                          _
# |  ____|                        | |
# | |__  __  _____ _ __ ___  _ __ | | ___  ___
# |  __| \ \/ / _ \ '_ ` _ \| '_ \| |/ _ \/ __|
# | |____ >  <  __/ | | | | | |_) | |  __/\__ \
# |______/_/\_\___|_| |_| |_| .__/|_|\___||___/
#                           | |
#                           |_|


#zm,cm = munk(10000)
#
#theta = 80
#zmax = 8000
#zstart = 1000
#tmax = 10
#
#plt.figure(1)
#plt.clf()
##Z1, C, Dx1, Dt, G, A,R,S, extime = raytrace_SnellDesc(zm,cm,angl,5)
##plt.plot(np.cumsum(Dx1),-Z1)
#Z2, C, Dx2, Dt, G, extime , Round = raytrace_SnellDesc3(zm,cm,zstart , zmax , tmax , theta)
#
#plt.clf()
#plt.plot(np.cumsum(Dx2),np.cumsum(-Z2))
#
#plt.axis('equal')
#



#Dz,Dx,Dt,Roun = multi_raytrace_SnellDesc(zm,cm,790,800,1,-2,2,0.1)
#
#plt.figure(2)
#plt.clf()
#
#plot_raytrace(Dz,Dx,Dt,Roun)

#plt.plot(np.cumsum(Dx2),-np.cumsum(Z2))

#zm,cm = munk(10000)
#
#theta = 80
#zmax = 8000
#zstart = 1000
#tmax = 6
#
#r,z,eta,zeta = raytrace_SnellDescRK(zm,cm,zstart , zmax , tmax , theta)



#   _____ _                _   _  __                 _        ______   _
#  / ____(_)              | | (_) \_\               | |      |  ____| | |
# | |     _ _ __ ___   ___| |_ _  ___ _ __ ___    __| | ___  | |__ ___| |_ ___
# | |    | | '_ ` _ \ / _ \ __| |/ _ \ '__/ _ \  / _` |/ _ \ |  __/ __| __/ __|
# | |____| | | | | | |  __/ |_| |  __/ | |  __/ | (_| |  __/ | | | (__| |_\__ \
#  \_____|_|_| |_| |_|\___|\__|_|\___|_|  \___|  \__,_|\___| |_|  \___|\__|___/
#
#


#def raytrace_SnellDesc2(Zinp, Cinp , zstart , zmax , tmax , theta):
#    """ Penser à utiliser raytrace_SnellDesc_frontend en priorité
#
#    La première profondeur ( Z(1) ) doit être zero (la surface)
#     (extrapolation sinon a prévoir)
#
#     ICI theta est FIXE, si recherche de theta : raytrace_seek
#
#     Basé sur Chadwell 2010 , p 175
#     ENTREE :
#     Zinp, Cinp : Sound Speend Profile (inp pour input)
#     theta : angle d'incidence suivant la surface,
#             compté dans le SENS TRIGO,
#             en degrés
#             (si rayon tracé "up to down" => theta est < 0)
#     zmax : la profondeur maxi ou on effectue le Ray tracing
#            Si = 0, ray tracing pout tout la colonne Z
#     mode : 'light' ou 'full' : light (par def) ne calcule que Dx et Dt
#     SORTIE :
#     Z : Profondeur [ 0 ,zmax ] (frontière de couche, taille N)
#     C : Vitesse [ 0 ,zmax ] (frontière de couche, taille N)
#     Dx : Déplacement en plani (couche, 0 + taille N-1)
#     Dt : Temps de propagation par couche (couche, taille 0 + N-1)
#     G : gradient dans chaque couche (couche, taille N-1)
#
#     NB : Dx Dt et R S : premier elt = 0 (pour coincider avec les autres vecteurs)
#     0) test si zmax > max(Z)
#    """
#    tic = time.time()
#
#
#    if np.any(np.abs(np.diff(Z)) < 0.01):
#        raise Exception('ERR : le pas de Z est trop petit, risque de gradient nul')
#
#    if zmax > np.max(Zinp):
#        warnings.warn('WARN : zmax > max(Z) => extrapolation de C')
#        Z, C = SSP_extrapolate(Zinp, Cinp, zmax, 100) # nargout=2
#
#    else:
#        Z = Zinp.copy()
#        C = Cinp.copy()
#    # 00) fabrication de Z avec zmax pour element maxi, et d'un C interpolé
#    # correspondant
#    if zmax != np.max(Z) and zmax != 0:
#        # warnings.warn("ATTENTION : zmax != max(Z) => decoupage de Z et C \
#        #\n pensez à le faire en amont ")
#        Z, C = SSP_cut(Z, C, zmax) # nargout=2
#    # recherche du gradient b de chaque couche => interpolation linéaire
#    n = len(Z)
#    m = len(Z) - 1
#    G = np.diff(C) / np.diff(Z)
#
#    # définition de k = cos(theta)/c => Invariant de Snell Descartes
#    theta = np.deg2rad(theta)
#    k = np.cos( theta) / C[ bisect.bisect_left(Z,zstart) ]
#
#    # Définition de la direction du rayon
#    if theta >= 0 :
#        uptodown = True
#    else:
#        uptodown = False
#
#    Dx,Dt,Dz = np.zeros(1),np.zeros(1),np.array([zstart])
#
#    kriter = 0
#    kritermax = 58000
#
#    # integration des distances et temps
#
#    while np.abs(np.sum(Dt) - tmax) > 10**-7  and kriter < kritermax:
#
#        zactual = np.sum(Dz)
#
#        # Inversion du sens si on rencontre le fond ou la surface
#        if zactual >= zmax:
#            uptodown = not uptodown
#        elif zactual <= 0:
#            uptodown = not uptodown
#
#        if uptodown:
#            i = bisect.bisect_left(Z,zactual)
#            g = G[i]
#            c1 = C[i]
#            c2 = C[i+1]
#            mult = 1
#        else:
#            i = bisect.bisect_left(Z,zactual) -1
#            g = G[i]
#            c1 = C[i+1]
#            c2 = C[i]
#            mult = -1
#
#        # Traitement dans le cas de reflexion
#        coeflimit = k ** 2 * c2 ** 2
#        if coeflimit >= 1:
#            uptodown = not uptodown
#
#            if uptodown:
#                i = bisect.bisect_left(Z,zactual)
#                g = G[i]
#                c1 = C[i]
#                c2 = C[i+1]
#                mult = 1
#            else:
#                i = bisect.bisect_left(Z,zactual) -1
#                g = G[i]
#                c1 = C[i+1]
#                c2 = C[i]
#                mult = -1
#
#            # Formule de Hovem 2013
#            dx = np.abs((2 / (k * g)) * ( np.sqrt(1 - k**2 * c1**2 )) )
#            dt = np.abs((2/g) * np.log( (1 + np.sqrt(1 - k**2 * c1**2))/(k * c1)  ) )
#            # Fin du tratement du cas de reflexion
#
#        else:
#            # Cas normal
#            dx = np.abs((1 / (k * g)) * (np.sqrt(1 - k**2 * c2**2 ) - np.sqrt(1 - k**2 * c1**2)))
#            dt = np.abs((1/g) * np.log( (c2/c1) * ((1 + np.sqrt(1 - k**2 * c1**2)) /(1 + np.sqrt(1 - k**2 * c2**2))) ) )
#
#        dz = mult * (Z[i+1] - Z[i])
#
#        sumDt = np.sum(Dt)
#        if sumDt + dt < tmax:
#            # Enregistrement des Deltas si on est dessus de tmax
#            Dx = np.append(Dx,dx)
#            Dt = np.append(Dt,dt)
#            Dz = np.append(Dz,dz)
#        else:
#            # Ajustement à la valeur tmax exacte
#            print uptodown
#            t = tmax - sumDt
#            c22 = 2*np.exp(t*g)*c1*(1+(-(k*c1-1)*(k*c1+1))**(1/2))/(k**2*np.exp(t*g)**2*c1**2+2+2*(-(k*c1-1)*(k*c1+1))**(1/2)-k**2*c1**2)
#
#            c2 = c22
#            dx = np.abs((1 / (k * g)) * (np.sqrt(1 - k**2 * c2**2 ) - np.sqrt(1 - k**2 * c1**2)))
#            dt = np.abs((1/g) * np.log( (c2/c1) * ((1 + np.sqrt(1 - k**2 * c1**2)) /(1 + np.sqrt(1 - k**2 * c2**2))) ) )
#            dz = mult * (c2 - c1)/g
#
## Recherche c2 de maniere iterative, inutile
##            dz = dz / 2
##            while (sumDt + dt - tmax) > 10 ** - 5:
##
##                c2 = g * dz + c1
##
##                dx = np.abs((1 / (k * g)) * (np.sqrt(1 - k**2 * c2**2 ) - np.sqrt(1 - k**2 * c1**2)))
##                dt = np.abs((1/g) * np.log( (c2/c1) * ((1 + np.sqrt(1 - k**2 * c1**2)) /(1 + np.sqrt(1 - k**2 * c2**2))) ) )
##
##                if sumDt + dt > tmax:
##                    dz = dz - dz / 2
##                else:
##                    dz = dz + dz / 2
#
#
#            Dx = np.append(Dx,dx)
#            Dt = np.append(Dt,dt)
#            Dz = np.append(Dz,dz)
#
#        kriter = kriter +1
#
#    toc = time.time()
#    extime = toc-tic
#    print kriter
#    print ("temps execution de SSP SnellDesc : %f" %(extime) )
#    print ("")
#
#    return Dz, C, Dx, Dt, G, extime

#def partial_derivative(func,var=0,point=[],dx=1e-6):
#    # BASE SUR CEQU'IL AVAIT SUR STACKOVERFLOW
#    # OBSOLETE
#    ''' si erreur :
#        val += weights[k]*func(x0+(k-ho)*dx,*args)
#        es tu bien sur que la fonction func ne renvoit qu'un seul output ?
#        sinon fait un wrapper ... '''
#    args = point[:]
#    def wraps(x):
#        args[var] = x
#        return func(*args)
#        try:
#            out = scipy.misc.derivative(wraps, point[var], dx = dx)
#        except:
#            print "Sur que la fonction func ne renvoit qu'un seul output ???"
#
#    return out
