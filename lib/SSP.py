# -*- coding: utf-8 -*-

# Autogenerated with SMOP version 0.23
# main.py /home/psakic01/THESE/CodeMk4/fonctions/SSP/SSP_cut.m

from geodezyx import *                   # Import the GeodeZYX modules
from geodezyx.externlib import *         # Import the external modules
from geodezyx.megalib.megalib import *   # Import the legacy modules names


import numpy as np
from scipy.io import loadmat,savemat
import os
import time
import scipy.interpolate as interp
import scipy as scipy
import scipy.optimize as optimize
import matplotlib.pyplot as plt
import sys
import raytrace as rt
import bisect
#import geodetik as geok

sys.dont_write_bytecode = True


def SSP_cut_2020(Z,C,zmax):
    """
    Simplified version of SSP cut
    """
    
    if np.all(Z < zmax):
        print("ERR: SSP_cut_2020: Z < zmax")
    
    ### get the z abouve zmax
    I_above_zmax = np.stack(np.squeeze(np.argwhere(Z <= zmax)))
    imax = np.max(I_above_zmax)    
    
    ### Case when the zmax is in Z
    if np.isclose(Z[imax],zmax): 
        Zout = Z[:imax+1]
        Cout = C[:imax+1]
    ### General case, we interpolate
    else:
        Zout = np.append(Z,zmax)
        g = (C[imax+1] - C[imax]) / (Z[imax+1] - Z[imax])
        c_zmax = g * (zmax - Z[imax]) + C[imax] 
        Cout = np.append(C,c_zmax)   
        
    return Zout , Cout

def SSP_remove_duplicate_DataFrame(Zinp,Cinp):
    """
    Remove duplicates in a SSP
    if duplicate C, gradient null => error
    """
    DF = pd.DataFrame(np.column_stack((Zinp,Cinp)))
    
    Bool = DF.duplicated(subset=1,keep='first')
    Bool = np.logical_not(Bool)
    
    Zout,Cout = Zinp[Bool],Cinp[Bool]
    
    return Zout,Cout


def SSP_remove_duplicate(Zinp,Cinp):
    """
    Remove duplicates in a SSP
    if duplicate C, gradient null => error
    """
    
    _ , I = np.unique(Cinp,return_index=True)
    
    I = np.sort(I)
    
    Zout = Zinp[I]    
    Cout = Cinp[I]
    
    return Zout,Cout


def SSP_cut(Zinp, Cinp, zmax):    

    """"coupe" un SSP au niveau d'une valeur maxi de z
     Il faut que zmax < max(Z)
    """
    Z = Zinp.copy()
    C = Cinp.copy()
    
    if np.isnan(zmax):
        print("WARN : zmax is NaN, something bad will surely happend ...")
    
    if zmax > np.max(Z):
          raise Exception("ERREUR : zmax > max(Z)")
    if (~((Z == zmax).any())):
        # <= zmax existe pas dans Z (cas classique)
        Z = np.append(Z,zmax)
        Z = np.sort(Z)
        izmax = np.flatnonzero(Z == zmax)

        C[izmax] = np.interp(Z[izmax],Zinp,Cinp)
        
    else:
        izmax = np.flatnonzero(Z == zmax)
        
    # <= zmax existe deja dans Z
    # test final si le zmax est unique
    if max(izmax.shape) != 1:
          raise Exception('zmax non unique (il existe deja dans la colonne Z)')
    
    Zout = Z[:izmax[0]+1] # +1, car premier elt que tu ne veux pas
    Cout = C[:izmax[0]+1]
    
    return Zout, Cout  
    
def SSP_cut_old(Z, C, zmax):
    # Avec une interpolation par spline ... pas très intelligent
    
    tic = time.time()

    """"coupe" un SSP au niveau d'une valeur maxi de z
     Il faut que zmax < max(Z)
    """
    if zmax > np.max(Z):
          raise Exception("ERREUR : zmax > max(Z)")
    if (~((Z == zmax).any())):
        # <= zmax existe pas dans Z (cas classique)
        s = interp.UnivariateSpline(Z,C,s=1)
        Z = np.append(Z,zmax)
        Z = np.sort(Z)
        izmax = np.flatnonzero(Z == zmax)

        C[izmax] = s(Z[izmax])
        
    else:
        izmax = np.flatnonzero(Z == zmax)
        
    # <= zmax existe deja dans Z
    # test final si le zmax est unique
    if max(izmax.shape) != 1:
          raise Exception('zmax non unique (il existe deja dans la colonne Z)')
        
    Zout = Z[:izmax+1]
    Cout = C[:izmax+1]
    
    toc = time.time()
    toctic = toc - tic
    print(("SSP cut : %f s" %(toctic) )) 
    
    return Zout, Cout

# Autogenerated with SMOP version 0.23
# main.py /home/psakic01/THESE/CodeMk4/fonctions/SSP/SSP_extrapolate.m

def SSP_extrapolate(Zinp, Cinp, zend, zpas):
    """SSP_extrapolate extrapole un SSP
    """
    
    if np.abs(Zinp[-1] - zend) < zpas: #### when the zpas is bigger than the requested zend 
        zpas = np.floor(np.abs(Zinp[-1] - zend) * 0.5)
        
    Zbis = np.arange(np.max(Zinp), zend, zpas)
        
    s = interp.UnivariateSpline(Zinp, Cinp, s=1)
    Cbis = s(Zbis)

    # attention : resultat different suivant le type d'interpolation
    # 'pchip''spline'
    # (normal en meme temps ...)
    
    Zout = np.hstack((Zinp[:-1], Zbis))
    Cout = np.hstack((Cinp[:-1], Cbis))
    
    return Zout, Cout

def SSP_extrapolate_linear(Zinp, Cinp, zend, zpas , zutil):
    """
    extrapole un SSP
    
    zutil : depth where the regression shall start
    
    """
    Zbis = np.arange(np.max(Zinp), zend, zpas)
    
    Zinp = np.array(Zinp)
    Cinp = np.array(Cinp)
        
    zutil_bool = Zinp >= zutil 
    print(zutil_bool)
    Zutil = Zinp[zutil_bool]
    Cutil = Cinp[zutil_bool]

    a , b = geok.linear_regression(Zutil,Cutil)

    Cbis = a*Zbis + b 

    # attention : resultat different suivant le type d'interpolation
    # 'pchip''spline'
    # (normal en meme temps ...)
    
    Zout = np.hstack((Zinp[:-1], Zbis))
    Cout = np.hstack((Cinp[:-1], Cbis))

    return Zout, Cout

def SSP_normalize(Z,C,normal_step=1):
    I    = interp.interp1d(Z,C)
    Znew =  np.arange(Z[0],Z[-1],normal_step)
    Cnew = I(Znew)
    return Znew , Cnew
  
def munk(zmax,pas=1):  
    z =np.arange(0,zmax,pas)    
    e = 0.00737
    ztilde = 2*(z-1300) / 1300
    c = 1500 * ( 1 + e * (ztilde - 1 + np.exp(-ztilde)))
    return z,c

def SSP_plot(Z,C,title = '',label='',color='x'):
    C = np.array(C)
    Z = np.array(Z)
    plt.plot(C,-Z,color,label=label)
    plt.ylabel('depth (m)')
    plt.xlabel('sound speed (m/s)')
    plt.suptitle(title)
    return None

def SSP_mean(Z,C,a,zmax):
    Z = np.array(Z)
    C = np.array(C)

    X,Z,T = rt.raytrace_SD1_frontend(Z,C,a,zmax)
    D = np.linalg.norm([X,Z])
    cout = D / T
    return cout



def munk_pseudo(z,epsilon=0.00737,zref1=1500,zref2=1300):
    ztilde  = 2    * (z-zref2) / zref2
    c       = zref1 * ( 1 + epsilon * (ztilde - 1 + np.exp(-ztilde)))
    return c    

def munk_pseudo_wrapper(xxx_todo_changeme,Z,C):
    (epsilon,zref1,zref2) = xxx_todo_changeme
    return np.array(C) - munk_pseudo(Z,epsilon,zref1,zref2)

def munk_pseudo_coef_calc(Z,C,out_ZC=True,out_normalized=True,norma_step=1,
                          norma_max_z=6000):
    coefs =  optimize.leastsq(munk_pseudo_wrapper,(0.00737,1500,1300),
                            args=(Z,C))[0]
    if out_ZC:
        if not out_normalized:
            return Z , munk_pseudo(Z,*coefs)
        else: 
            Z = np.arange(0,norma_max_z,norma_step)
            return Z , munk_pseudo(Z,*coefs)
    else:
        return coefs

def soundspeed(S, T, D, equation='mackenzie'):
    """ src : https://github.com/ocefpaf/python-oceans/blob/master/oceans/
    sw_extras/sw_extras.py
    Various sound-speed equations.
    
    1)  soundspeed(s, t, d) returns the sound speed (m/sec) given vectors
       of salinity (ppt), temperature (deg C) and DEPTH (m) using
       the formula of Mackenzie:  Mackenzie, K.V. "Nine-term Equation for
       Sound Speed in the Oceans", J. Acoust. Soc. Am. 70 (1981), 807-812.

    2) soundspeed(s, t, p, 'del_grosso') returns the sound speed (m/sec)given
       vectors of salinity (ppt), temperature (deg C), and  PRESSURE (dbar)
       using the Del Grosso equation:  Del Grosso, "A New Equation for the
       speed of sound in Natural Waters", J. Acoust. Soc. Am. 56#4 (1974).

    3) soundspeed(s, t, p, 'chen') returns the sound speed (m/sec) given
       vectors of salinity (ppt), temperature (deg C), and PRESSURE (dbar)
       using the Chen and Millero equation:  Chen and Millero, "The Sound
       Speed in Seawater", J. Acoust. Soc. Am. 62 (1977), 1129-1135.

    Notes: RP (WHOI) 3/dec/91
            Added state equation ss
    """
    if equation == 'mackenzie':
        c = 1.44896e3
        t = 4.591e0
        t2 = -5.304e-2
        t3 = 2.374e-4
        s = 1.340e0
        d = 1.630e-2
        d2 = 1.675e-7
        ts = -1.025e-2
        td3 = -7.139e-13
        ssp = (c + t * T + t2 * T * T + t3 * T * T * T + s * (S-35.0) + d *
               D + d2 * D * D + ts * T * (S-35.0) + td3 * T * D * D * D)
    elif equation == 'del_grosso':
        # Del grosso uses pressure in kg/cm^2.  To get to this from dbars
        # we  must divide by "g".  From the UNESCO algorithms (referring to
        # ANON (1970) BULLETIN GEODESIQUE) we have this formula for g as a
        # function of latitude and pressure.  We set latitude to 45 degrees
        # for convenience!
        XX = np.sin(45 * np.pi/180)
        GR = 9.780318 * (1.0 + (5.2788E-3 + 2.36E-5 * XX) * XX) + 1.092E-6 * D
        P = D / GR
        # This is from VSOUND.f.
        C000 = 1402.392
        DCT = (0.501109398873e1 - (0.550946843172e-1 - 0.221535969240e-3 * T) *
               T) * T
        DCS = (0.132952290781e1 + 0.128955756844e-3 * S) * S
        DCP = (0.156059257041e0 + (0.244998688441e-4 - 0.883392332513e-8 * P) *
               P) * P
        DCSTP = ((-0.127562783426e-1 * T * S + 0.635191613389e-2 * T * P +
                  0.265484716608e-7 * T * T * P * P - 0.159349479045e-5 * T *
                  P * P + 0.522116437235e-9 * T * P * P * P -
                  0.438031096213e-6 * T * T * T * P) - 0.161674495909e-8 * S *
                 S * P * P + 0.968403156410e-4 * T * T * S +
                 0.485639620015e-5 * T * S * S * P - 0.340597039004e-3 * T *
                 S * P)
        ssp = C000 + DCT + DCS + DCP + DCSTP
    elif equation == 'chen':
        P0 = D
        # This is copied directly from the UNESCO algorithms.
        # CHECKVALUE: SVEL=1731.995 M/S, S=40 (IPSS-78),T=40 DEG C,P=10000 DBAR
        # SCALE PRESSURE TO BARS
        P = P0 / 10.
        SR = np.sqrt(np.abs(S))
        # S**2 TERM.
        D = 1.727E-3 - 7.9836E-6 * P
        # S**3/2 TERM.
        B1 = 7.3637E-5 + 1.7945E-7 * T
        B0 = -1.922E-2 - 4.42E-5 * T
        B = B0 + B1 * P
        # S**1 TERM.
        A3 = (-3.389E-13 * T + 6.649E-12) * T + 1.100E-10
        A2 = ((7.988E-12 * T - 1.6002E-10) * T + 9.1041E-9) * T - 3.9064E-7
        A1 = ((((-2.0122E-10 * T + 1.0507E-8) * T - 6.4885E-8) * T -
               1.2580E-5) * T + 9.4742E-5)
        A0 = ((((-3.21E-8 * T + 2.006E-6) * T + 7.164E-5) * T - 1.262E-2) *
              T + 1.389)
        A = ((A3 * P + A2) * P + A1) * P + A0
        # S**0 TERM.
        C3 = (-2.3643E-12 * T + 3.8504E-10) * T - 9.7729E-9
        C2 = (((1.0405E-12 * T - 2.5335E-10) * T + 2.5974E-8) * T -
              1.7107E-6) * T + 3.1260E-5
        C1 = (((-6.1185E-10 * T + 1.3621E-7) * T - 8.1788E-6) * T +
              6.8982E-4) * T + 0.153563
        C0 = ((((3.1464E-9 * T - 1.47800E-6) * T + 3.3420E-4) * T -
               5.80852E-2) * T + 5.03711) * T + 1402.388
        C = ((C3 * P + C2) * P + C1) * P + C0
        # SOUND SPEED RETURN.
        ssp = C + (A + B * SR + D * S) * S
    else:
        raise TypeError('Unrecognizable equation specified: %s' % equation)
    return ssp
    
#def leroy2008(T,S,Z,PHI):
#    
#    C = 1402.5 + 5*T - 5.44 * 10**-2 * T**2 + 2.1*10**-4 * T**3 
#    + 1.33*S - 1.23 * 10**-2 * S*T + 8.7*10**-5 * S * T**2 
#    + 1.56*10**-2 * Z + 2.55*10**-7 * Z**2 - 7.3 * 10**-12 * Z**3 
#    + 1.2*10**-6  * Z * (PHI−45) - 9.5 * 10**-13*T*Z**3 
#    + 3 * 10**-7 * T**2 * Z + 1.43*10**-5*S*Z
#    
#    return C

def depth(p, lat):
    """
    from seawater.eos80 library

    Calculates depth in meters from pressure in dbars.

    Parameters
    ----------
    p : array_like
        pressure [db].
    lat : number or array_like
          latitude in decimal degrees north [-90..+90].

    Returns
    -------
    z : array_like
        depth [meters]

    Examples
    --------
    >>> # UNESCO 1983 data p30.
    >>> import seawater as sw
    >>> lat = [0, 30, 45, 90]
    >>> p = [[  500,   500,   500,  500],
    ...      [ 5000,  5000,  5000, 5000],
    ...      [10000, 10000, 10000, 10000]]
    >>> sw.dpth(p, lat)
    array([[  496.65299239,   495.99772917,   495.3427354 ,   494.03357499],
           [ 4915.04099112,  4908.55954332,  4902.08075214,  4889.13132561],
           [ 9725.47087508,  9712.6530721 ,  9699.84050403,  9674.23144056]])

    References
    ----------
    .. [1] Fofonoff, P. and Millard, R.C. Jr UNESCO 1983. Algorithms for
       computation of fundamental properties of seawater. UNESCO Tech. Pap. in
       Mar. Sci., No. 44, 53 pp.
       http://unesdoc.unesco.org/images/0005/000598/059832eb.pdf    
    """
    p, lat = list(map(np.asanyarray, (p, lat)))

    # Eqn 25, p26.  UNESCO 1983.
    c = [9.72659, -2.2512e-5, 2.279e-10, -1.82e-15]
    gam_dash = 2.184e-6

    lat = abs(lat)
    X = np.sin(lat * deg2rad)
    X = X * X

    bot_line = (9.780318 * (1.0 + (5.2788e-3 + 2.36e-5 * X) * X) +
                gam_dash * 0.5 * p)
    top_line = (((c[3] * p + c[2]) * p + c[1]) * p + c[0]) * p
    return top_line / bot_line

def pres(depth, lat):
    """
    from seawater.eos80 library
    
    Calculates pressure in dbars from depth in meters.

    Parameters
    ----------
    depth : array_like
            depth [meters]
    lat : array_like
          latitude in decimal degrees north [-90..+90]

    Returns
    -------
    p : array_like
           pressure [db]

    Examples
    --------
    >>> import seawater as sw
    >>> depth, lat = 7321.45, 30
    >>> sw.pres(depth,lat)
    7500.0065130118019

    References
    ----------
    .. [1] Saunders, Peter M., 1981: Practical Conversion of Pressure to Depth.
       J. Phys. Oceanogr., 11, 573-574.
       doi: 10.1175/1520-0485(1981)011<0573:PCOPTD>2.0.CO;2

    """
    depth, lat = list(map(np.asanyarray, (depth, lat)))

    X = np.sin(np.abs(np.deg2rad(lat)))
    C1 = 5.92e-3 + X ** 2 * 5.25e-3
    return ((1 - C1) - (((1 - C1) ** 2) - (8.84e-6 * depth)) ** 0.5) / 4.42e-6

def SSP_calc(D,T,S,lat):
    """
    OBSOLETE => utiliser soundspeed
    D : ultra mal foutu => c'est la pression !!!
    T : Temperature
    S : Salinity
    """   
        
    # Del grosso uses pressure in kg/cm^2. To get to this from dbars we must 
    # divide by "g". From the UNESCO algorithms (referring to ANON (1970) 
    # BULLETIN GEODESIQUE) we have this formula for g as a function of latitude 
    # and pressure. We set latitude to 45 degrees for convenience!

    XX=np.sin(np.deg2rad(lat))**2;
    
    GR = 9.780318*(1.0+(5.2788E-3+2.36E-5*XX)*XX) + 1.092E-6*D;

    P=D/GR;

    C000 = 1402.392
    DCT = (0.501109398873e1-(0.550946843172e-1 - 0.221535969240e-3*T)*T)*T
    DCS = (0.132952290781e1 + 0.128955756844e-3*S)*S;
    DCP = (0.156059257041e0 + (0.244998688441e-4 - 0.883392332513e-8*P)*P)*P;
    DCSTP = -0.127562783426e-1*T*S + 0.635191613389e-2*T*P +0.265484716608e-7*T*T*P*P \
    - 0.159349479045e-5*T*P*P+0.522116437235e-9*T*P*P*P - 0.438031096213e-6*T*T*T*P
    DCSTP=DCSTP - 0.161674495909e-8*S*S*P*P + 0.968403156410e-4*T*T*S+ \
    0.485639620015e-5*T*S*S*P - 0.340597039004e-3*T*S*P
    ssp = C000 + DCT + DCS + DCP + DCSTP
  
    return ssp
   
def standard_depths(dmax):
    """
    Standard depth convention
    http://data.nodc.noaa.gov/woa/WOD13/CODES/PDF/standard_depths.pdf
    A depth below the sea surface at which water properties should be measured 
    and reported, either directly or by interpolation, according to the proposal 
    by the International Association of Physical Oceanography in 1936. 
    http://www.nodc.noaa.gov/OC5/SELECT/dbsearch/depth_definition.html
    """
    d1 = np.arange(0,100,5)
    d2 = np.arange(100,500,25)
    d3 = np.arange(500,2000,50)
    d4 = np.arange(2000,15000,100)
    
    d = np.hstack((d1,d2,d3,d4))
    d = d[d <= dmax]
    return d
    
   
def SSP_light_old(Zin , Ain , Vmaxbound = [ 100 , 500 , 2000 , 10898 ] , 
              Vresol = [ 5 , 25 , 50 , 100] , coef = 1 ):              
    # Allège un SSP, suivant la convention par défaut :
    # intervalle    résolution
    # 0   - 100         5
    # 100 - 500        25
    # 500 - 2000       50
    # 2000 -          100
    # Standard depth convention
    # http://data.nodc.noaa.gov/woa/WOD13/CODES/PDF/standard_depths.pdf
    # A depth below the sea surface at which water properties should be measured 
    # and reported, either directly or by interpolation, according to the proposal 
    # by the International Association of Physical Oceanography in 1936. 
    # http://www.nodc.noaa.gov/OC5/SELECT/dbsearch/depth_definition.html
    #
    # A est peux contenir n'importe quelle donnée
    # OPTIONNEL : Vmaxbound & Vresol & coef
    # Vmaxbound = vecteur des frontières inferieures d'intervalles ( le dernier
    # elt doit être >> max(Zin) ) la frontière est incluse dans la couche du dessus
    # Vresol : la résolution de chaque intervalle
    # coef : coefficient diviseur de Vresol
    
    if Zin.shape != Ain.shape  :
        raise Exception("Z et A de longueur differente")
        
    L = Zin.shape[0]
    kategorie = 0
    i = 0

    Zout = np.empty(0)
    Aout = np.empty(0)

    Zout = []
    Aout = []
        
    maxbound = Vmaxbound[kategorie]
    resol = Vresol[kategorie]
    
    while i < L-1 :  
        print('aaaa',i , L-1)
        #Zout = np.append(Zout, Zin[i])
        #Aout = np.append(Aout, Ain[i])
        Zout.append(Zin[i])
        Aout.append(Ain[i])

        if Zin[i] > maxbound + 1: # 1 marge de sécurité
            kategorie += 1
            maxbound = Vmaxbound[kategorie]
            resol = Vresol[kategorie] / coef
                 
        znexttheo = Zout[-1] + resol 
        i = np.where( np.abs(Zin - znexttheo) 
                      == np.min(np.abs(Zin - znexttheo)))[0].item()
                      
    if Zout[-1] != Zin[-1]:
       #Zout = np.append(Zout,Zin[-1])
       #Aout = np.append(Aout,Ain[-1])
       Zout.append(Zin[-1])
       Aout.append(Ain[-1])


    return np.array(Zout), np.array(Aout)

def SSP_light(Zin , Ain , Vmaxbound = [ 100 , 500 , 2000 , 10898 ] , 
              Vresol = [ 5 , 25 , 50 , 100] , coef = 1 ):   
    """
     Allège un SSP, suivant la convention par défaut :
     intervalle    résolution
     0   - 100         5
     100 - 500        25
     500 - 2000       50
     2000 -          100
     Standard depth convention
     http://data.nodc.noaa.gov/woa/WOD13/CODES/PDF/standard_depths.pdf
     A depth below the sea surface at which water properties should be measured 
     and reported, either directly or by interpolation, according to the proposal 
     by the International Association of Physical Oceanography in 1936. 
     http://www.nodc.noaa.gov/OC5/SELECT/dbsearch/depth_definition.html
    
     A est peux contenir n'importe quelle donnée
     OPTIONNEL : Vmaxbound & Vresol & coef
     Vmaxbound = vecteur des frontières inferieures d'intervalles ( le dernier
     elt doit être >> max(Zin) ) la frontière est incluse dans la couche du dessus
     Vresol : la résolution de chaque intervalle
     coef : coefficient diviseur de Vresol
    """
    
    Zout = []
    Aout = []    
    
    for z,a in zip(Zin , Ain):
        if len(Zout) == 0:
            Zout.append(z)
            Aout.append(a)
        i_couche       = bisect.bisect_left(Vmaxbound,z)
        resol_4_couche = Vresol[i_couche]
        
        if np.abs(Zout[-1] - z) < resol_4_couche:
            continue
        else:
            Zout.append(z)
            Aout.append(a)
            
    return np.array(Zout) , np.array(Aout)
    
def read_CTD_gedesea(filein):
    data = np.loadtxt(filein)
    Z = data[:,4]
    C = soundspeed(data[:,6],data[:,2],data[:,1])
    
    C2 = np.array([c for (z,c) in sorted(zip(Z,C))])
    Z2 = np.array(sorted(Z))
    
    Zredondant = np.array([])
    C3 = []
    Z3 = []
    for z in Z2:
        if z in Zredondant:
            continue
        boo = np.abs(z  - Z2) < 0.1
        zout = np.mean(Z2[boo])
        cout = np.mean(C2[boo])
        Zredondant = np.concatenate((Zredondant,Z2[boo]))
        C3.append(cout)
        Z3.append(zout)     
    return Z3 , C3


def SSP_integrate(Z,C):
    return np.trapz(C,Z) / (Z[-1] - Z[0])


def SSP_integrate_frontend(Z,C,step=1):
    Zout = np.arange(Z[0],Z[-1]+1, step)
    Cout = np.array(len(Zout) * [SSP_integrate(Z,C)])
    Cout = Cout + np.random.randn(len(Cout)) * 0.001
    print("AAAAA SSP_integrate_frontend")
    print(Zout,Cout)
    return Zout , Cout
